#!/bin/bash
#
# Aragora Status Page Deployment Script
#
# Deploys Uptime Kuma status page with pre-configured monitors.
# SOC 2 Control: A1-01 - Public availability information
#
# Usage:
#   ./deploy-status-page.sh [options]
#
# Options:
#   --domain DOMAIN      Status page domain (default: status.aragora.ai)
#   --api-url URL        API URL to monitor (default: https://api.aragora.ai)
#   --port PORT          Local port for Uptime Kuma (default: 3001)
#   --nginx              Generate nginx configuration
#   --dry-run            Show what would be done without executing
#   --help               Show this help message
#
# Examples:
#   ./deploy-status-page.sh
#   ./deploy-status-page.sh --domain status.example.com --api-url https://api.example.com
#   ./deploy-status-page.sh --nginx > /etc/nginx/sites-available/status.conf

set -euo pipefail

# Default configuration
DOMAIN="${DOMAIN:-status.aragora.ai}"
API_URL="${API_URL:-https://api.aragora.ai}"
PORT="${PORT:-3001}"
DRY_RUN=false
GENERATE_NGINX=false

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

show_help() {
    head -30 "$0" | tail -25 | sed 's/^#//'
    exit 0
}

generate_nginx_config() {
    cat << EOF
# Nginx configuration for Aragora Status Page
# Generated by deploy-status-page.sh
#
# Install: sudo cp this-file /etc/nginx/sites-available/status.conf
#          sudo ln -s /etc/nginx/sites-available/status.conf /etc/nginx/sites-enabled/
#          sudo nginx -t && sudo systemctl reload nginx

# HTTP redirect to HTTPS
server {
    listen 80;
    listen [::]:80;
    server_name ${DOMAIN};

    location /.well-known/acme-challenge/ {
        root /var/www/certbot;
    }

    location / {
        return 301 https://\$host\$request_uri;
    }
}

# HTTPS server
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${DOMAIN};

    # SSL certificates (Let's Encrypt)
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

    # SSL configuration
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Modern TLS configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Proxy to Uptime Kuma
    location / {
        proxy_pass http://127.0.0.1:${PORT};
        proxy_http_version 1.1;

        # WebSocket support
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";

        # Proxy headers
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Buffer settings
        proxy_buffering off;
        proxy_buffer_size 4k;
    }

    # Health check endpoint for load balancer
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }
}
EOF
}

check_prerequisites() {
    log_info "Checking prerequisites..."

    local missing=()

    if ! command -v docker &> /dev/null; then
        missing+=("docker")
    fi

    if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
        missing+=("docker-compose")
    fi

    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing prerequisites: ${missing[*]}"
        log_info "Please install the missing tools and try again."
        exit 1
    fi

    log_success "All prerequisites met"
}

check_docker_running() {
    if ! docker info &> /dev/null; then
        log_error "Docker daemon is not running"
        exit 1
    fi
}

deploy_uptime_kuma() {
    log_info "Deploying Uptime Kuma..."

    local compose_file="$(dirname "$0")/docker-compose.yml"

    if [ ! -f "$compose_file" ]; then
        log_error "docker-compose.yml not found at $compose_file"
        exit 1
    fi

    if $DRY_RUN; then
        log_info "[DRY RUN] Would run: docker-compose -f $compose_file up -d"
        return
    fi

    cd "$(dirname "$0")"

    # Pull latest image
    log_info "Pulling latest Uptime Kuma image..."
    docker-compose pull

    # Start container
    log_info "Starting Uptime Kuma container..."
    docker-compose up -d

    # Wait for container to be healthy
    log_info "Waiting for Uptime Kuma to be ready..."
    local max_attempts=30
    local attempt=1

    while [ $attempt -le $max_attempts ]; do
        if curl -s "http://localhost:${PORT}" > /dev/null 2>&1; then
            log_success "Uptime Kuma is ready!"
            break
        fi

        if [ $attempt -eq $max_attempts ]; then
            log_error "Uptime Kuma failed to start within timeout"
            docker-compose logs
            exit 1
        fi

        echo -n "."
        sleep 2
        ((attempt++))
    done
    echo
}

show_next_steps() {
    echo
    echo "=============================================="
    echo "        Status Page Deployment Complete       "
    echo "=============================================="
    echo
    echo "Access Uptime Kuma at: http://localhost:${PORT}"
    echo
    echo "Next Steps:"
    echo "1. Create admin account at http://localhost:${PORT}"
    echo "2. Import monitors from monitors-seed.json (if available)"
    echo "3. Create public status page:"
    echo "   - Name: Aragora Status"
    echo "   - Slug: aragora"
    echo
    echo "4. Configure DNS:"
    echo "   - Add A/CNAME record for ${DOMAIN} pointing to this server"
    echo
    echo "5. Set up SSL (if using nginx directly):"
    echo "   certbot --nginx -d ${DOMAIN}"
    echo
    echo "6. Generate nginx config:"
    echo "   $0 --nginx > /etc/nginx/sites-available/status.conf"
    echo
    echo "Monitors to Configure:"
    echo "  - API Health:      ${API_URL}/api/health"
    echo "  - API Services:    ${API_URL}/api/health/detailed"
    echo "  - WebSocket:       ${API_URL}/api/ws/stats"
    echo
    echo "Documentation: $(dirname "$0")/README.md"
    echo "=============================================="
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --domain)
            DOMAIN="$2"
            shift 2
            ;;
        --api-url)
            API_URL="$2"
            shift 2
            ;;
        --port)
            PORT="$2"
            shift 2
            ;;
        --nginx)
            GENERATE_NGINX=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --help|-h)
            show_help
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            ;;
    esac
done

# Main execution
if $GENERATE_NGINX; then
    generate_nginx_config
    exit 0
fi

echo
echo "======================================"
echo "  Aragora Status Page Deployment"
echo "======================================"
echo
echo "Configuration:"
echo "  Domain:   ${DOMAIN}"
echo "  API URL:  ${API_URL}"
echo "  Port:     ${PORT}"
echo "  Dry Run:  ${DRY_RUN}"
echo

if $DRY_RUN; then
    log_warn "Running in DRY RUN mode - no changes will be made"
    echo
fi

check_prerequisites
check_docker_running
deploy_uptime_kuma
show_next_steps
