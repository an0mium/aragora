"""
Tests for vulnerability handler functions
(aragora/server/handlers/codebase/security/vulnerability.py).

Covers all six handler functions:
- handle_scan_repository: POST trigger a scan
- handle_get_scan_status: GET scan status (latest or by ID)
- handle_get_vulnerabilities: GET vulnerabilities from latest scan
- handle_get_cve_details: GET CVE details from database
- handle_query_package_vulnerabilities: GET package vulnerabilities
- handle_list_scans: GET scan history

Tests include: happy path, error paths, edge cases, filtering,
pagination, sorting, security (path traversal, injection), and
concurrent scan protection.
"""

from __future__ import annotations

import asyncio
import threading
from datetime import datetime, timezone
from typing import Any
from unittest.mock import AsyncMock, MagicMock, patch

import pytest

from aragora.analysis.codebase import (
    DependencyInfo,
    ScanResult,
    VulnerabilityFinding,
    VulnerabilitySeverity,
)
from aragora.server.handlers.codebase.security.vulnerability import (
    handle_get_cve_details,
    handle_get_scan_status,
    handle_get_vulnerabilities,
    handle_list_scans,
    handle_query_package_vulnerabilities,
    handle_scan_repository,
)


# ============================================================================
# Helpers
# ============================================================================


def _body(result) -> dict:
    """Extract the data payload from a HandlerResult.

    success_response wraps in {"success": true, "data": {...}}.
    error_response wraps in {"success": false, "error": "..."}.
    """
    import json

    if isinstance(result, dict):
        raw = result
    else:
        raw = json.loads(result.body)
    if isinstance(raw, dict) and raw.get("success") and "data" in raw:
        return raw["data"]
    return raw


def _status(result) -> int:
    """Extract HTTP status code from a HandlerResult."""
    if isinstance(result, dict):
        return result.get("status_code", 200)
    return result.status_code


def _make_scan(
    scan_id: str = "scan_001",
    repo_id: str = "test-repo",
    status: str = "completed",
    branch: str | None = "main",
    commit_sha: str | None = "abc123",
    dependencies: list[DependencyInfo] | None = None,
    started_at: datetime | None = None,
    completed_at: datetime | None = None,
) -> ScanResult:
    """Create a ScanResult for testing."""
    return ScanResult(
        scan_id=scan_id,
        repository=repo_id,
        branch=branch,
        commit_sha=commit_sha,
        status=status,
        dependencies=dependencies or [],
        started_at=started_at or datetime(2024, 1, 15, 10, 0, tzinfo=timezone.utc),
        completed_at=completed_at or datetime(2024, 1, 15, 10, 5, tzinfo=timezone.utc),
    )


def _make_vuln(
    cve_id: str = "CVE-2024-0001",
    severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH,
    title: str = "Test Vulnerability",
    description: str = "A test vulnerability",
) -> VulnerabilityFinding:
    """Create a VulnerabilityFinding for testing."""
    return VulnerabilityFinding(
        id=cve_id,
        title=title,
        description=description,
        severity=severity,
    )


def _make_dep(
    name: str = "requests",
    version: str = "2.28.0",
    ecosystem: str = "pip",
    vulns: list[VulnerabilityFinding] | None = None,
) -> DependencyInfo:
    """Create a DependencyInfo for testing."""
    return DependencyInfo(
        name=name,
        version=version,
        ecosystem=ecosystem,
        vulnerabilities=vulns or [],
    )


# ============================================================================
# Fixtures
# ============================================================================


@pytest.fixture(autouse=True)
def clear_scan_storage():
    """Clear in-memory scan stores between tests."""
    from aragora.server.handlers.codebase.security.storage import (
        _running_scans,
        _scan_results,
    )

    _scan_results.clear()
    _running_scans.clear()
    yield
    _scan_results.clear()
    _running_scans.clear()


@pytest.fixture
def repo_scans():
    """Get scan storage for test-repo."""
    from aragora.server.handlers.codebase.security.storage import (
        get_or_create_repo_scans,
    )

    return get_or_create_repo_scans("test-repo")


@pytest.fixture
def running_scans():
    """Get the running scans dictionary."""
    from aragora.server.handlers.codebase.security.storage import get_running_scans

    return get_running_scans()


@pytest.fixture
def scan_lock():
    """Get the scan lock."""
    from aragora.server.handlers.codebase.security.storage import get_scan_lock

    return get_scan_lock()


# ============================================================================
# handle_scan_repository tests
# ============================================================================


class TestHandleScanRepository:
    """Tests for handle_scan_repository."""

    @pytest.mark.asyncio
    async def test_start_scan_success(self, running_scans, monkeypatch):
        """Starting a new scan returns 200 with scan_id and running status."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
            branch="main",
            commit_sha="abc123",
        )

        assert _status(result) == 200
        body = _body(result)
        assert body["status"] == "running"
        assert body["repository"] == "test-repo"
        assert "scan_id" in body
        assert body["scan_id"].startswith("scan_")

    @pytest.mark.asyncio
    async def test_start_scan_generates_repo_id_when_none(self, monkeypatch):
        """When repo_id is None, a UUID-based one is generated."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(repo_path="/tmp/repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["repository"].startswith("repo_")

    @pytest.mark.asyncio
    async def test_duplicate_scan_returns_409(self, running_scans):
        """If a scan is already running for the repo, 409 is returned."""
        # Create a running task
        loop = asyncio.get_event_loop()
        future = loop.create_future()
        task = asyncio.ensure_future(future)
        running_scans["test-repo"] = task

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
        )

        assert _status(result) == 409
        body = _body(result)
        assert "already in progress" in body.get("error", "").lower()

        # Clean up
        future.set_result(None)
        await task

    @pytest.mark.asyncio
    async def test_completed_scan_allows_rescan(self, running_scans, monkeypatch):
        """If a previous scan is done, a new scan can be started."""
        # Create a completed task
        completed_task = asyncio.ensure_future(asyncio.sleep(0))
        await completed_task
        running_scans["test-repo"] = completed_task

        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
        )

        assert _status(result) == 200

    @pytest.mark.asyncio
    async def test_scan_stores_initial_result(self, repo_scans, monkeypatch):
        """The scan result is stored immediately with running status."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
        )

        scan_id = _body(result)["scan_id"]
        assert scan_id in repo_scans
        assert repo_scans[scan_id].status == "running"

    @pytest.mark.asyncio
    async def test_scan_with_workspace_and_user(self, monkeypatch):
        """Workspace and user IDs are passed through."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
            workspace_id="ws_001",
            user_id="user_001",
        )

        assert _status(result) == 200

    @pytest.mark.asyncio
    async def test_scan_without_branch_or_commit(self, monkeypatch):
        """Scan works without optional branch and commit_sha."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan(branch=None, commit_sha=None)

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
        )

        assert _status(result) == 200


# ============================================================================
# handle_get_scan_status tests
# ============================================================================


class TestHandleGetScanStatus:
    """Tests for handle_get_scan_status."""

    @pytest.mark.asyncio
    async def test_get_specific_scan(self, repo_scans):
        """Get a specific scan by ID."""
        scan = _make_scan(scan_id="scan_abc")
        repo_scans["scan_abc"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_abc")

        assert _status(result) == 200
        body = _body(result)
        assert "scan_result" in body
        assert body["scan_result"]["scan_id"] == "scan_abc"

    @pytest.mark.asyncio
    async def test_get_nonexistent_scan(self, repo_scans):
        """Getting a scan that doesn't exist returns 404."""
        result = await handle_get_scan_status(repo_id="test-repo", scan_id="nonexistent")

        assert _status(result) == 404
        body = _body(result)
        assert "not found" in body.get("error", "").lower()

    @pytest.mark.asyncio
    async def test_get_latest_scan(self, repo_scans):
        """Get the latest scan when no scan_id is specified."""
        older = _make_scan(
            scan_id="scan_old",
            started_at=datetime(2024, 1, 1, tzinfo=timezone.utc),
        )
        newer = _make_scan(
            scan_id="scan_new",
            started_at=datetime(2024, 6, 1, tzinfo=timezone.utc),
        )
        repo_scans["scan_old"] = older
        repo_scans["scan_new"] = newer

        result = await handle_get_scan_status(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scan_result"]["scan_id"] == "scan_new"

    @pytest.mark.asyncio
    async def test_get_latest_no_scans(self):
        """When no scans exist for a repo, 404 is returned."""
        result = await handle_get_scan_status(repo_id="empty-repo")

        assert _status(result) == 404
        body = _body(result)
        assert "no scans" in body.get("error", "").lower()

    @pytest.mark.asyncio
    async def test_get_scan_returns_full_data(self, repo_scans):
        """The returned scan result includes all expected fields."""
        scan = _make_scan(scan_id="scan_full", branch="develop", commit_sha="def456")
        repo_scans["scan_full"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_full")

        assert _status(result) == 200
        body = _body(result)
        sr = body["scan_result"]
        assert sr["branch"] == "develop"
        assert sr["commit_sha"] == "def456"
        assert sr["repository"] == "test-repo"

    @pytest.mark.asyncio
    async def test_get_latest_with_single_scan(self, repo_scans):
        """Latest works with a single scan."""
        scan = _make_scan(scan_id="only_scan")
        repo_scans["only_scan"] = scan

        result = await handle_get_scan_status(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scan_result"]["scan_id"] == "only_scan"


# ============================================================================
# handle_get_vulnerabilities tests
# ============================================================================


class TestHandleGetVulnerabilities:
    """Tests for handle_get_vulnerabilities."""

    @pytest.mark.asyncio
    async def test_no_scans_returns_404(self):
        """When no scans exist, 404 is returned."""
        result = await handle_get_vulnerabilities(repo_id="empty-repo")

        assert _status(result) == 404

    @pytest.mark.asyncio
    async def test_no_completed_scans_returns_404(self, repo_scans):
        """When only running scans exist, 404 is returned."""
        scan = _make_scan(scan_id="scan_run", status="running")
        repo_scans["scan_run"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 404
        body = _body(result)
        assert "no completed" in body.get("error", "").lower()

    @pytest.mark.asyncio
    async def test_returns_vulnerabilities(self, repo_scans):
        """Returns vulnerabilities from the latest completed scan."""
        vuln = _make_vuln("CVE-2024-001", VulnerabilitySeverity.HIGH)
        dep = _make_dep("requests", "2.28.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_v", dependencies=[dep])
        repo_scans["scan_v"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert len(body["vulnerabilities"]) == 1
        assert body["vulnerabilities"][0]["package_name"] == "requests"
        assert body["vulnerabilities"][0]["package_version"] == "2.28.0"
        assert body["vulnerabilities"][0]["package_ecosystem"] == "pip"
        assert body["scan_id"] == "scan_v"

    @pytest.mark.asyncio
    async def test_filter_by_severity(self, repo_scans):
        """Filtering by severity returns only matching vulnerabilities."""
        vuln_high = _make_vuln("CVE-1", VulnerabilitySeverity.HIGH)
        vuln_low = _make_vuln("CVE-2", VulnerabilitySeverity.LOW)
        dep = _make_dep("pkg", "1.0", "pip", [vuln_high, vuln_low])
        scan = _make_scan(scan_id="scan_f", dependencies=[dep])
        repo_scans["scan_f"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", severity="high")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["vulnerabilities"][0]["severity"] == "high"

    @pytest.mark.asyncio
    async def test_filter_by_package_name(self, repo_scans):
        """Filtering by package name is case-insensitive substring match."""
        vuln1 = _make_vuln("CVE-1")
        vuln2 = _make_vuln("CVE-2")
        dep1 = _make_dep("requests", "2.28.0", "pip", [vuln1])
        dep2 = _make_dep("flask", "2.0.0", "pip", [vuln2])
        scan = _make_scan(scan_id="scan_p", dependencies=[dep1, dep2])
        repo_scans["scan_p"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", package="Request")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["vulnerabilities"][0]["package_name"] == "requests"

    @pytest.mark.asyncio
    async def test_filter_by_ecosystem(self, repo_scans):
        """Filtering by ecosystem returns only matching entries."""
        vuln1 = _make_vuln("CVE-1")
        vuln2 = _make_vuln("CVE-2")
        dep1 = _make_dep("requests", "2.28.0", "pip", [vuln1])
        dep2 = _make_dep("lodash", "4.17.0", "npm", [vuln2])
        scan = _make_scan(scan_id="scan_e", dependencies=[dep1, dep2])
        repo_scans["scan_e"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", ecosystem="npm")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["vulnerabilities"][0]["package_ecosystem"] == "npm"

    @pytest.mark.asyncio
    async def test_combined_filters(self, repo_scans):
        """Multiple filters are combined (AND logic)."""
        vuln1 = _make_vuln("CVE-1", VulnerabilitySeverity.CRITICAL)
        vuln2 = _make_vuln("CVE-2", VulnerabilitySeverity.LOW)
        vuln3 = _make_vuln("CVE-3", VulnerabilitySeverity.CRITICAL)
        dep1 = _make_dep("requests", "2.28.0", "pip", [vuln1])
        dep2 = _make_dep("flask", "2.0.0", "pip", [vuln2])
        dep3 = _make_dep("axios", "0.21.0", "npm", [vuln3])
        scan = _make_scan(scan_id="scan_c", dependencies=[dep1, dep2, dep3])
        repo_scans["scan_c"] = scan

        result = await handle_get_vulnerabilities(
            repo_id="test-repo",
            severity="critical",
            ecosystem="pip",
        )

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["vulnerabilities"][0]["package_name"] == "requests"

    @pytest.mark.asyncio
    async def test_pagination_limit(self, repo_scans):
        """Limit parameter controls the number of returned results."""
        vulns = [_make_vuln(f"CVE-{i}", VulnerabilitySeverity.MEDIUM) for i in range(10)]
        deps = [_make_dep(f"pkg-{i}", "1.0", "pip", [v]) for i, v in enumerate(vulns)]
        scan = _make_scan(scan_id="scan_l", dependencies=deps)
        repo_scans["scan_l"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", limit=3)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 10
        assert len(body["vulnerabilities"]) == 3
        assert body["limit"] == 3

    @pytest.mark.asyncio
    async def test_pagination_offset(self, repo_scans):
        """Offset parameter skips initial results."""
        vulns = [_make_vuln(f"CVE-{i}", VulnerabilitySeverity.MEDIUM) for i in range(5)]
        deps = [_make_dep(f"pkg-{i}", "1.0", "pip", [v]) for i, v in enumerate(vulns)]
        scan = _make_scan(scan_id="scan_o", dependencies=deps)
        repo_scans["scan_o"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", limit=2, offset=3)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 5
        assert len(body["vulnerabilities"]) == 2
        assert body["offset"] == 3

    @pytest.mark.asyncio
    async def test_pagination_beyond_total(self, repo_scans):
        """Offset beyond total returns empty results."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("pkg", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_b", dependencies=[dep])
        repo_scans["scan_b"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", offset=100)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert len(body["vulnerabilities"]) == 0

    @pytest.mark.asyncio
    async def test_severity_sort_order(self, repo_scans):
        """Vulnerabilities are sorted by severity: critical > high > medium > low."""
        vuln_low = _make_vuln("CVE-LOW", VulnerabilitySeverity.LOW)
        vuln_crit = _make_vuln("CVE-CRIT", VulnerabilitySeverity.CRITICAL)
        vuln_med = _make_vuln("CVE-MED", VulnerabilitySeverity.MEDIUM)
        vuln_high = _make_vuln("CVE-HIGH", VulnerabilitySeverity.HIGH)

        dep1 = _make_dep("a", "1.0", "pip", [vuln_low])
        dep2 = _make_dep("b", "1.0", "pip", [vuln_crit])
        dep3 = _make_dep("c", "1.0", "pip", [vuln_med])
        dep4 = _make_dep("d", "1.0", "pip", [vuln_high])

        scan = _make_scan(scan_id="scan_s", dependencies=[dep1, dep2, dep3, dep4])
        repo_scans["scan_s"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        severities = [v["severity"] for v in body["vulnerabilities"]]
        assert severities == ["critical", "high", "medium", "low"]

    @pytest.mark.asyncio
    async def test_unknown_severity_sorted_last(self, repo_scans):
        """Unknown severity is sorted after low."""
        vuln_unk = _make_vuln("CVE-UNK", VulnerabilitySeverity.UNKNOWN)
        vuln_low = _make_vuln("CVE-LOW", VulnerabilitySeverity.LOW)
        dep1 = _make_dep("a", "1.0", "pip", [vuln_unk])
        dep2 = _make_dep("b", "1.0", "pip", [vuln_low])
        scan = _make_scan(scan_id="scan_u", dependencies=[dep1, dep2])
        repo_scans["scan_u"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        severities = [v["severity"] for v in body["vulnerabilities"]]
        assert severities == ["low", "unknown"]

    @pytest.mark.asyncio
    async def test_uses_latest_completed_scan(self, repo_scans):
        """When multiple completed scans exist, uses the latest one."""
        vuln_old = _make_vuln("CVE-OLD")
        dep_old = _make_dep("old-pkg", "1.0", "pip", [vuln_old])
        old_scan = _make_scan(
            scan_id="scan_old",
            dependencies=[dep_old],
            started_at=datetime(2024, 1, 1, tzinfo=timezone.utc),
        )

        vuln_new = _make_vuln("CVE-NEW")
        dep_new = _make_dep("new-pkg", "2.0", "pip", [vuln_new])
        new_scan = _make_scan(
            scan_id="scan_new",
            dependencies=[dep_new],
            started_at=datetime(2024, 6, 1, tzinfo=timezone.utc),
        )

        repo_scans["scan_old"] = old_scan
        repo_scans["scan_new"] = new_scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scan_id"] == "scan_new"

    @pytest.mark.asyncio
    async def test_no_vulnerabilities_returns_empty_list(self, repo_scans):
        """When no vulnerabilities found, returns empty list with total 0."""
        dep = _make_dep("safe-pkg", "1.0", "pip", [])
        scan = _make_scan(scan_id="scan_safe", dependencies=[dep])
        repo_scans["scan_safe"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0
        assert body["vulnerabilities"] == []

    @pytest.mark.asyncio
    async def test_filter_no_matches(self, repo_scans):
        """When filter matches nothing, returns empty results."""
        vuln = _make_vuln("CVE-1", VulnerabilitySeverity.HIGH)
        dep = _make_dep("requests", "2.28.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_nm", dependencies=[dep])
        repo_scans["scan_nm"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", severity="critical")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_multiple_vulns_per_dependency(self, repo_scans):
        """A dependency with multiple vulnerabilities returns all of them."""
        vuln1 = _make_vuln("CVE-1", VulnerabilitySeverity.HIGH)
        vuln2 = _make_vuln("CVE-2", VulnerabilitySeverity.MEDIUM)
        vuln3 = _make_vuln("CVE-3", VulnerabilitySeverity.LOW)
        dep = _make_dep("pkg", "1.0", "pip", [vuln1, vuln2, vuln3])
        scan = _make_scan(scan_id="scan_mv", dependencies=[dep])
        repo_scans["scan_mv"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 3

    @pytest.mark.asyncio
    async def test_default_pagination_values(self, repo_scans):
        """Default limit and offset values are returned in response."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("pkg", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_dp", dependencies=[dep])
        repo_scans["scan_dp"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["limit"] == 100
        assert body["offset"] == 0


# ============================================================================
# handle_get_cve_details tests
# ============================================================================


class TestHandleGetCveDetails:
    """Tests for handle_get_cve_details."""

    @pytest.mark.asyncio
    async def test_get_cve_success(self):
        """Successfully retrieves CVE details."""
        mock_vuln = MagicMock()
        mock_vuln.to_dict.return_value = {
            "cve_id": "CVE-2024-1234",
            "severity": "critical",
            "description": "A critical vulnerability",
        }

        mock_client = AsyncMock()
        mock_client.get_cve.return_value = mock_vuln

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-1234")

        assert _status(result) == 200
        body = _body(result)
        assert "vulnerability" in body
        assert body["vulnerability"]["cve_id"] == "CVE-2024-1234"

    @pytest.mark.asyncio
    async def test_get_cve_not_found(self):
        """When CVE is not found, returns 404."""
        mock_client = AsyncMock()
        mock_client.get_cve.return_value = None

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-9999-9999")

        assert _status(result) == 404
        body = _body(result)
        assert "CVE-9999-9999" in body.get("error", "")

    @pytest.mark.asyncio
    async def test_get_cve_adds_cve_id_if_missing(self):
        """If to_dict doesn't include cve_id, it's added automatically."""
        mock_vuln = MagicMock()
        mock_vuln.to_dict.return_value = {
            "severity": "high",
            "description": "Some vulnerability",
        }

        mock_client = AsyncMock()
        mock_client.get_cve.return_value = mock_vuln

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-5678")

        assert _status(result) == 200
        body = _body(result)
        assert body["vulnerability"]["cve_id"] == "CVE-2024-5678"

    @pytest.mark.asyncio
    async def test_get_cve_client_error(self):
        """When client raises an error, returns 500."""
        mock_client = AsyncMock()
        mock_client.get_cve.side_effect = OSError("Connection failed")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-1234")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_get_cve_timeout_error(self):
        """When client times out, returns 500."""
        mock_client = AsyncMock()
        mock_client.get_cve.side_effect = asyncio.TimeoutError()

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-1234")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_get_cve_value_error(self):
        """When client raises ValueError, returns 500."""
        mock_client = AsyncMock()
        mock_client.get_cve.side_effect = ValueError("Invalid CVE format")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="invalid")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_get_cve_preserves_existing_cve_id(self):
        """If to_dict already includes cve_id, it's not overwritten."""
        mock_vuln = MagicMock()
        mock_vuln.to_dict.return_value = {
            "cve_id": "CVE-2024-1234",
            "severity": "medium",
        }

        mock_client = AsyncMock()
        mock_client.get_cve.return_value = mock_vuln

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-1234")

        assert _status(result) == 200
        body = _body(result)
        assert body["vulnerability"]["cve_id"] == "CVE-2024-1234"


# ============================================================================
# handle_query_package_vulnerabilities tests
# ============================================================================


class TestHandleQueryPackageVulnerabilities:
    """Tests for handle_query_package_vulnerabilities."""

    @pytest.mark.asyncio
    async def test_query_package_success(self):
        """Successfully queries package vulnerabilities."""
        mock_vuln = MagicMock()
        mock_vuln.to_dict.return_value = {
            "id": "CVE-2024-001",
            "severity": "high",
        }

        mock_client = AsyncMock()
        mock_client.query_package.return_value = [mock_vuln]

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="requests",
                ecosystem="pip",
                version="2.28.0",
            )

        assert _status(result) == 200
        body = _body(result)
        assert body["package"] == "requests"
        assert body["ecosystem"] == "pip"
        assert body["version"] == "2.28.0"
        assert body["total"] == 1
        assert len(body["vulnerabilities"]) == 1

    @pytest.mark.asyncio
    async def test_query_package_no_vulnerabilities(self):
        """Package with no vulnerabilities returns empty list."""
        mock_client = AsyncMock()
        mock_client.query_package.return_value = []

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="safe-package",
                ecosystem="npm",
            )

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0
        assert body["vulnerabilities"] == []

    @pytest.mark.asyncio
    async def test_query_package_without_version(self):
        """Query without specifying version returns all versions."""
        mock_client = AsyncMock()
        mock_client.query_package.return_value = []

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="lodash",
                ecosystem="npm",
            )

        assert _status(result) == 200
        body = _body(result)
        assert body["version"] is None

    @pytest.mark.asyncio
    async def test_query_package_multiple_vulns(self):
        """Package with multiple vulnerabilities returns all of them."""
        vulns = []
        for i in range(5):
            mock_vuln = MagicMock()
            mock_vuln.to_dict.return_value = {"id": f"CVE-{i}", "severity": "medium"}
            vulns.append(mock_vuln)

        mock_client = AsyncMock()
        mock_client.query_package.return_value = vulns

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="express",
                ecosystem="npm",
                version="4.17.0",
            )

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 5

    @pytest.mark.asyncio
    async def test_query_package_client_error(self):
        """When client raises an error, returns 500."""
        mock_client = AsyncMock()
        mock_client.query_package.side_effect = RuntimeError("Service unavailable")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="requests",
                ecosystem="pip",
            )

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_query_package_passes_args_correctly(self):
        """Arguments are passed correctly to the client."""
        mock_client = AsyncMock()
        mock_client.query_package.return_value = []

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            await handle_query_package_vulnerabilities(
                package_name="django",
                ecosystem="pip",
                version="4.2.0",
            )

        mock_client.query_package.assert_called_once_with(
            package_name="django",
            ecosystem="pip",
            version="4.2.0",
        )


# ============================================================================
# handle_list_scans tests
# ============================================================================


class TestHandleListScans:
    """Tests for handle_list_scans."""

    @pytest.mark.asyncio
    async def test_list_empty_scans(self):
        """When no scans exist, returns empty list."""
        result = await handle_list_scans(repo_id="empty-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scans"] == []
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_list_scans_with_data(self, repo_scans):
        """Returns list of scans with summary data."""
        scan = _make_scan(scan_id="scan_001", status="completed")
        scan.total_dependencies = 50
        scan.vulnerable_dependencies = 3
        scan.critical_count = 1
        scan.high_count = 2
        scan.medium_count = 0
        scan.low_count = 0
        repo_scans["scan_001"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["scans"][0]["scan_id"] == "scan_001"
        assert body["scans"][0]["status"] == "completed"
        assert body["scans"][0]["summary"] is not None
        assert body["scans"][0]["summary"]["total_dependencies"] == 50

    @pytest.mark.asyncio
    async def test_list_scans_running_has_no_summary(self, repo_scans):
        """Running scans have summary=None."""
        scan = _make_scan(scan_id="scan_run", status="running")
        repo_scans["scan_run"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scans"][0]["summary"] is None

    @pytest.mark.asyncio
    async def test_list_scans_sorted_descending(self, repo_scans):
        """Scans are sorted by start time descending (newest first)."""
        old_scan = _make_scan(
            scan_id="scan_old",
            started_at=datetime(2024, 1, 1, tzinfo=timezone.utc),
        )
        new_scan = _make_scan(
            scan_id="scan_new",
            started_at=datetime(2024, 6, 1, tzinfo=timezone.utc),
        )
        repo_scans["scan_old"] = old_scan
        repo_scans["scan_new"] = new_scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scans"][0]["scan_id"] == "scan_new"
        assert body["scans"][1]["scan_id"] == "scan_old"

    @pytest.mark.asyncio
    async def test_list_scans_filter_by_status(self, repo_scans):
        """Filtering by status returns only matching scans."""
        completed = _make_scan(scan_id="scan_c", status="completed")
        running = _make_scan(scan_id="scan_r", status="running")
        failed = _make_scan(scan_id="scan_f", status="failed")
        repo_scans["scan_c"] = completed
        repo_scans["scan_r"] = running
        repo_scans["scan_f"] = failed

        result = await handle_list_scans(repo_id="test-repo", status="completed")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["scans"][0]["scan_id"] == "scan_c"

    @pytest.mark.asyncio
    async def test_list_scans_filter_by_running_status(self, repo_scans):
        """Filtering by 'running' status works."""
        running = _make_scan(scan_id="scan_r", status="running")
        completed = _make_scan(scan_id="scan_c", status="completed")
        repo_scans["scan_r"] = running
        repo_scans["scan_c"] = completed

        result = await handle_list_scans(repo_id="test-repo", status="running")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1
        assert body["scans"][0]["status"] == "running"

    @pytest.mark.asyncio
    async def test_list_scans_pagination_limit(self, repo_scans):
        """Limit parameter controls number of returned scans."""
        for i in range(10):
            scan = _make_scan(
                scan_id=f"scan_{i:03d}",
                started_at=datetime(2024, 1, i + 1, tzinfo=timezone.utc),
            )
            repo_scans[f"scan_{i:03d}"] = scan

        result = await handle_list_scans(repo_id="test-repo", limit=3)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 10
        assert len(body["scans"]) == 3
        assert body["limit"] == 3

    @pytest.mark.asyncio
    async def test_list_scans_pagination_offset(self, repo_scans):
        """Offset parameter skips initial scans."""
        for i in range(5):
            scan = _make_scan(
                scan_id=f"scan_{i:03d}",
                started_at=datetime(2024, 1, i + 1, tzinfo=timezone.utc),
            )
            repo_scans[f"scan_{i:03d}"] = scan

        result = await handle_list_scans(repo_id="test-repo", limit=2, offset=3)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 5
        assert len(body["scans"]) == 2
        assert body["offset"] == 3

    @pytest.mark.asyncio
    async def test_list_scans_default_pagination(self, repo_scans):
        """Default limit is 20 and offset is 0."""
        scan = _make_scan(scan_id="scan_001")
        repo_scans["scan_001"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["limit"] == 20
        assert body["offset"] == 0

    @pytest.mark.asyncio
    async def test_list_scans_completed_at_null(self, repo_scans):
        """Running scans have completed_at as None."""
        scan = _make_scan(scan_id="scan_run", status="running")
        scan.completed_at = None
        repo_scans["scan_run"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scans"][0]["completed_at"] is None

    @pytest.mark.asyncio
    async def test_list_scans_filter_no_matches(self, repo_scans):
        """Filtering with no matches returns empty list."""
        scan = _make_scan(scan_id="scan_001", status="completed")
        repo_scans["scan_001"] = scan

        result = await handle_list_scans(repo_id="test-repo", status="failed")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0
        assert body["scans"] == []

    @pytest.mark.asyncio
    async def test_list_scans_started_at_iso_format(self, repo_scans):
        """started_at is returned in ISO format."""
        dt = datetime(2024, 3, 15, 14, 30, 0, tzinfo=timezone.utc)
        scan = _make_scan(scan_id="scan_dt", started_at=dt)
        repo_scans["scan_dt"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert "2024-03-15" in body["scans"][0]["started_at"]


# ============================================================================
# _get_cve_client_cls tests
# ============================================================================


class TestGetCveClientCls:
    """Tests for the _get_cve_client_cls resolution function."""

    def test_returns_base_when_no_patching(self):
        """Returns the base CVEClient when nothing is patched."""
        from aragora.server.handlers.codebase.security.vulnerability import (
            _get_cve_client_cls,
            _BASE_CVECLIENT,
        )

        cls = _get_cve_client_cls()
        assert cls is _BASE_CVECLIENT

    def test_returns_patched_module_level(self, monkeypatch):
        """Returns the patched CVEClient when module-level is patched."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        mock_cls = MagicMock()
        monkeypatch.setattr(vuln_mod, "CVEClient", mock_cls)

        cls = vuln_mod._get_cve_client_cls()
        assert cls is mock_cls


# ============================================================================
# Security tests
# ============================================================================


class TestSecurityInputValidation:
    """Tests for security-related input handling."""

    @pytest.mark.asyncio
    async def test_path_traversal_in_repo_id_scan(self, monkeypatch):
        """Path traversal in repo_id should not affect storage isolation."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        # This tests that ../etc gets stored as a literal repo_id
        # (the actual path traversal protection is in the handler class)
        result = await handle_scan_repository(
            repo_path="/tmp/repo",
            repo_id="../etc",
        )
        # The function itself does not validate repo_id - that's done by the
        # SecurityHandler._validate_repo_id. The function just stores it.
        assert _status(result) == 200

    @pytest.mark.asyncio
    async def test_very_long_repo_id_in_scan_status(self):
        """Very long repo_id doesn't crash the handler."""
        long_id = "a" * 10000
        result = await handle_get_scan_status(repo_id=long_id)
        # Should return 404 (no scans for this repo)
        assert _status(result) == 404

    @pytest.mark.asyncio
    async def test_special_characters_in_package_filter(self, repo_scans):
        """Special characters in package filter are handled safely."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("requests", "2.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_sp", dependencies=[dep])
        repo_scans["scan_sp"] = scan

        result = await handle_get_vulnerabilities(
            repo_id="test-repo",
            package="<script>alert('xss')</script>",
        )

        assert _status(result) == 200
        body = _body(result)
        # No match, but no crash
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_null_bytes_in_cve_id(self):
        """Null bytes in CVE ID are handled."""
        mock_client = AsyncMock()
        mock_client.get_cve.return_value = None

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024\x00-1234")

        # Should either return 404 or 500, but not crash
        assert _status(result) in (404, 500)

    @pytest.mark.asyncio
    async def test_sql_injection_in_ecosystem_filter(self, repo_scans):
        """SQL injection attempt in ecosystem filter is handled safely."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("pkg", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_sql", dependencies=[dep])
        repo_scans["scan_sql"] = scan

        result = await handle_get_vulnerabilities(
            repo_id="test-repo",
            ecosystem="pip'; DROP TABLE scans; --",
        )

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_unicode_in_package_name_query(self):
        """Unicode characters in package name query don't crash."""
        mock_client = AsyncMock()
        mock_client.query_package.return_value = []

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="\u2603snowman\u2603",
                ecosystem="pip",
            )

        assert _status(result) == 200


# ============================================================================
# Error handling tests
# ============================================================================


class TestErrorHandling:
    """Tests for error handling in all handler functions."""

    @pytest.mark.asyncio
    async def test_scan_repository_runtime_error(self, monkeypatch):
        """RuntimeError during scan start returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_running_scans",
            MagicMock(side_effect=RuntimeError("broken")),
        )

        result = await handle_scan_repository(repo_path="/tmp/repo", repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_get_scan_status_type_error(self, monkeypatch):
        """TypeError in get_scan_status returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_or_create_repo_scans",
            MagicMock(side_effect=TypeError("bad type")),
        )

        result = await handle_get_scan_status(repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_attribute_error(self, monkeypatch):
        """AttributeError in get_vulnerabilities returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        # Force an AttributeError inside the handler's try block
        def _broken_get_or_create(repo_id):
            raise AttributeError("broken storage")

        monkeypatch.setattr(vuln_mod, "get_or_create_repo_scans", _broken_get_or_create)

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_list_scans_value_error(self, monkeypatch):
        """ValueError in list_scans returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_or_create_repo_scans",
            MagicMock(side_effect=ValueError("bad")),
        )

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_query_package_key_error(self):
        """KeyError in query_package returns 500."""
        mock_client = AsyncMock()
        mock_client.query_package.side_effect = KeyError("missing key")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(
                package_name="pkg",
                ecosystem="pip",
            )

        assert _status(result) == 500


# ============================================================================
# Edge cases
# ============================================================================


class TestEdgeCases:
    """Edge case tests."""

    @pytest.mark.asyncio
    async def test_empty_repo_id_scan_status(self):
        """Empty string repo_id returns 404."""
        result = await handle_get_scan_status(repo_id="")
        assert _status(result) == 404

    @pytest.mark.asyncio
    async def test_empty_repo_id_list_scans(self):
        """Empty string repo_id returns empty list."""
        result = await handle_list_scans(repo_id="")
        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_list_scans_many_items(self, repo_scans):
        """Handle large number of scans without issues."""
        for i in range(100):
            scan = _make_scan(
                scan_id=f"scan_{i:05d}",
                started_at=datetime(2024, 1, 1, i // 24, i % 60, tzinfo=timezone.utc),
            )
            repo_scans[f"scan_{i:05d}"] = scan

        result = await handle_list_scans(repo_id="test-repo", limit=10)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 100
        assert len(body["scans"]) == 10

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_scan_with_no_dependencies(self, repo_scans):
        """Completed scan with empty dependencies list returns 0 vulnerabilities."""
        scan = _make_scan(scan_id="scan_empty", dependencies=[])
        repo_scans["scan_empty"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 0

    @pytest.mark.asyncio
    async def test_get_vulnerabilities_dep_with_no_vulns(self, repo_scans):
        """Dependencies without vulnerabilities are skipped."""
        dep_safe = _make_dep("safe", "1.0", "pip", [])
        dep_vuln = _make_dep("vuln", "1.0", "pip", [_make_vuln("CVE-1")])
        scan = _make_scan(scan_id="scan_mixed", dependencies=[dep_safe, dep_vuln])
        repo_scans["scan_mixed"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1

    @pytest.mark.asyncio
    async def test_scan_status_specific_scan_empty_repo(self):
        """Getting a specific scan_id from an empty repo returns 404."""
        result = await handle_get_scan_status(repo_id="nonexistent-repo", scan_id="scan_123")
        assert _status(result) == 404

    @pytest.mark.asyncio
    async def test_list_scans_offset_equals_total(self, repo_scans):
        """Offset equal to total returns empty list."""
        for i in range(3):
            scan = _make_scan(
                scan_id=f"scan_{i}",
                started_at=datetime(2024, 1, i + 1, tzinfo=timezone.utc),
            )
            repo_scans[f"scan_{i}"] = scan

        result = await handle_list_scans(repo_id="test-repo", offset=3)

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 3
        assert len(body["scans"]) == 0

    @pytest.mark.asyncio
    async def test_vulnerabilities_enriched_with_package_info(self, repo_scans):
        """Each vulnerability dict is enriched with package_name, version, ecosystem."""
        vuln = _make_vuln("CVE-1", VulnerabilitySeverity.HIGH)
        dep = _make_dep("django", "4.2.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_enriched", dependencies=[dep])
        repo_scans["scan_enriched"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        v = body["vulnerabilities"][0]
        assert v["package_name"] == "django"
        assert v["package_version"] == "4.2.0"
        assert v["package_ecosystem"] == "pip"

    @pytest.mark.asyncio
    async def test_scan_completed_at_in_list(self, repo_scans):
        """Completed scan shows completed_at in isoformat."""
        dt = datetime(2024, 7, 20, 15, 45, 0, tzinfo=timezone.utc)
        scan = _make_scan(scan_id="scan_dt", status="completed", completed_at=dt)
        repo_scans["scan_dt"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert "2024-07-20" in body["scans"][0]["completed_at"]

    @pytest.mark.asyncio
    async def test_scan_summary_fields_in_list(self, repo_scans):
        """Completed scan summary has all expected count fields."""
        scan = _make_scan(scan_id="scan_summary", status="completed")
        scan.total_dependencies = 100
        scan.vulnerable_dependencies = 10
        scan.critical_count = 2
        scan.high_count = 3
        scan.medium_count = 3
        scan.low_count = 2
        repo_scans["scan_summary"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        summary = body["scans"][0]["summary"]
        assert summary["total_dependencies"] == 100
        assert summary["vulnerable_dependencies"] == 10
        assert summary["critical_count"] == 2
        assert summary["high_count"] == 3
        assert summary["medium_count"] == 3
        assert summary["low_count"] == 2


# ============================================================================
# Scan task lifecycle tests
# ============================================================================


class TestScanTaskLifecycle:
    """Tests for the async scan task behavior."""

    @pytest.mark.asyncio
    async def test_scan_creates_task_in_running_scans(self, running_scans, monkeypatch):
        """After starting a scan, the task is in running_scans."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="my-repo",
        )

        assert _status(result) == 200
        assert "my-repo" in running_scans
        assert isinstance(running_scans["my-repo"], asyncio.Task)

    @pytest.mark.asyncio
    async def test_scan_id_format(self, monkeypatch):
        """Generated scan_id has correct format."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result = await handle_scan_repository(
            repo_path="/tmp/test-repo",
            repo_id="test-repo",
        )

        body = _body(result)
        scan_id = body["scan_id"]
        assert scan_id.startswith("scan_")
        assert len(scan_id) == 17  # "scan_" + 12 hex chars

    @pytest.mark.asyncio
    async def test_multiple_repos_independent(self, running_scans, monkeypatch):
        """Scans for different repos run independently."""
        mock_scanner = AsyncMock()
        mock_scanner.scan_repository.return_value = _make_scan()

        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(vuln_mod, "get_scanner", lambda: mock_scanner)
        monkeypatch.setattr(vuln_mod, "emit_scan_events", AsyncMock())

        result1 = await handle_scan_repository(repo_path="/tmp/repo1", repo_id="repo-1")
        result2 = await handle_scan_repository(repo_path="/tmp/repo2", repo_id="repo-2")

        assert _status(result1) == 200
        assert _status(result2) == 200
        assert "repo-1" in running_scans
        assert "repo-2" in running_scans


# ============================================================================
# Vulnerability data integrity tests
# ============================================================================


class TestVulnerabilityDataIntegrity:
    """Tests for data integrity in vulnerability responses."""

    @pytest.mark.asyncio
    async def test_vulnerability_dict_includes_original_fields(self, repo_scans):
        """Vulnerability dict includes fields from VulnerabilityFinding.to_dict."""
        vuln = VulnerabilityFinding(
            id="CVE-2024-001",
            title="Buffer Overflow",
            description="A buffer overflow vulnerability",
            severity=VulnerabilitySeverity.CRITICAL,
            cvss_score=9.8,
        )
        dep = _make_dep("libc", "2.31", "apt", [vuln])
        scan = _make_scan(scan_id="scan_data", dependencies=[dep])
        repo_scans["scan_data"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        v = body["vulnerabilities"][0]
        assert v["id"] == "CVE-2024-001"
        assert v["title"] == "Buffer Overflow"
        assert v["severity"] == "critical"
        assert v["cvss_score"] == 9.8

    @pytest.mark.asyncio
    async def test_multiple_deps_multiple_vulns(self, repo_scans):
        """All vulnerabilities from all dependencies are collected."""
        dep1 = _make_dep(
            "pkg-a",
            "1.0",
            "pip",
            [
                _make_vuln("CVE-1"),
                _make_vuln("CVE-2"),
            ],
        )
        dep2 = _make_dep(
            "pkg-b",
            "2.0",
            "pip",
            [
                _make_vuln("CVE-3"),
            ],
        )
        dep3 = _make_dep(
            "pkg-c",
            "3.0",
            "npm",
            [
                _make_vuln("CVE-4"),
                _make_vuln("CVE-5"),
                _make_vuln("CVE-6"),
            ],
        )
        scan = _make_scan(scan_id="scan_multi", dependencies=[dep1, dep2, dep3])
        repo_scans["scan_multi"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 6

    @pytest.mark.asyncio
    async def test_package_name_filter_case_insensitive(self, repo_scans):
        """Package name filter is case-insensitive."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("MyPackage", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_ci", dependencies=[dep])
        repo_scans["scan_ci"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", package="mypackage")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1

    @pytest.mark.asyncio
    async def test_package_name_filter_substring_match(self, repo_scans):
        """Package name filter matches substrings."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("python-requests", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_sub", dependencies=[dep])
        repo_scans["scan_sub"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", package="request")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 1

    @pytest.mark.asyncio
    async def test_ecosystem_filter_exact_match(self, repo_scans):
        """Ecosystem filter requires exact match (not substring)."""
        vuln = _make_vuln("CVE-1")
        dep = _make_dep("pkg", "1.0", "pip", [vuln])
        scan = _make_scan(scan_id="scan_exact", dependencies=[dep])
        repo_scans["scan_exact"] = scan

        result = await handle_get_vulnerabilities(repo_id="test-repo", ecosystem="pi")

        assert _status(result) == 200
        body = _body(result)
        # "pi" != "pip" (exact match)
        assert body["total"] == 0


# ============================================================================
# Scan status with different scan states
# ============================================================================


class TestScanStatusVariousStates:
    """Tests for scan status with different scan states."""

    @pytest.mark.asyncio
    async def test_get_running_scan_status(self, repo_scans):
        """Can retrieve status of a running scan."""
        scan = _make_scan(scan_id="scan_run", status="running")
        scan.completed_at = None
        repo_scans["scan_run"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_run")

        assert _status(result) == 200
        body = _body(result)
        assert body["scan_result"]["status"] == "running"

    @pytest.mark.asyncio
    async def test_get_failed_scan_status(self, repo_scans):
        """Can retrieve status of a failed scan."""
        scan = _make_scan(scan_id="scan_fail", status="failed")
        scan.error = "Connection timeout"
        repo_scans["scan_fail"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_fail")

        assert _status(result) == 200
        body = _body(result)
        assert body["scan_result"]["status"] == "failed"

    @pytest.mark.asyncio
    async def test_list_mixed_status_scans(self, repo_scans):
        """List scans with various statuses shows all."""
        for status in ("completed", "running", "failed"):
            scan = _make_scan(scan_id=f"scan_{status}", status=status)
            repo_scans[f"scan_{status}"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["total"] == 3
        statuses = {s["status"] for s in body["scans"]}
        assert statuses == {"completed", "running", "failed"}

    @pytest.mark.asyncio
    async def test_failed_scan_has_no_summary_in_list(self, repo_scans):
        """Failed scans have summary=None in list response."""
        scan = _make_scan(scan_id="scan_fail", status="failed")
        repo_scans["scan_fail"] = scan

        result = await handle_list_scans(repo_id="test-repo")

        assert _status(result) == 200
        body = _body(result)
        assert body["scans"][0]["summary"] is None


# ============================================================================
# CVE client resolution edge cases
# ============================================================================


class TestCveClientResolutionEdgeCases:
    """Edge case tests for _get_cve_client_cls resolution."""

    def test_returns_base_when_security_module_import_fails(self, monkeypatch):
        """Falls back to base when security module import raises ImportError."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        # Ensure CVEClient hasn't been patched at module level
        original = vuln_mod._BASE_CVECLIENT

        # _get_cve_client_cls should still return the base class
        cls = vuln_mod._get_cve_client_cls()
        assert cls is original

    @pytest.mark.asyncio
    async def test_cve_details_with_runtime_error(self):
        """RuntimeError from CVE client is caught and returns 500."""
        mock_client = AsyncMock()
        mock_client.get_cve.side_effect = RuntimeError("Internal error")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_get_cve_details(cve_id="CVE-2024-0001")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_package_vuln_os_error(self):
        """OSError from CVE client is caught and returns 500."""
        mock_client = AsyncMock()
        mock_client.query_package.side_effect = OSError("Network error")

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(package_name="pkg", ecosystem="pip")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_package_vuln_timeout(self):
        """TimeoutError from CVE client is caught and returns 500."""
        mock_client = AsyncMock()
        mock_client.query_package.side_effect = asyncio.TimeoutError()

        mock_cls = MagicMock(return_value=mock_client)

        with patch(
            "aragora.server.handlers.codebase.security.vulnerability._get_cve_client_cls",
            return_value=mock_cls,
        ):
            result = await handle_query_package_vulnerabilities(package_name="pkg", ecosystem="pip")

        assert _status(result) == 500


# ============================================================================
# Scan repository error recovery
# ============================================================================


class TestScanRepositoryErrorRecovery:
    """Tests for scan error recovery and cleanup."""

    @pytest.mark.asyncio
    async def test_scan_os_error_returns_500(self, monkeypatch):
        """OSError during scan start returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_running_scans",
            MagicMock(side_effect=OSError("disk full")),
        )

        result = await handle_scan_repository(repo_path="/tmp/repo", repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_scan_value_error_returns_500(self, monkeypatch):
        """ValueError during scan start returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_or_create_repo_scans",
            MagicMock(side_effect=ValueError("bad value")),
        )

        result = await handle_scan_repository(repo_path="/tmp/repo", repo_id="test-repo")

        assert _status(result) == 500

    @pytest.mark.asyncio
    async def test_scan_type_error_returns_500(self, monkeypatch):
        """TypeError during scan start returns 500."""
        import aragora.server.handlers.codebase.security.vulnerability as vuln_mod

        monkeypatch.setattr(
            vuln_mod,
            "get_scan_lock",
            MagicMock(side_effect=TypeError("bad type")),
        )

        result = await handle_scan_repository(repo_path="/tmp/repo", repo_id="test-repo")

        assert _status(result) == 500


# ============================================================================
# Response envelope format tests
# ============================================================================


class TestResponseFormat:
    """Tests verifying the response envelope format."""

    @pytest.mark.asyncio
    async def test_success_response_has_envelope(self, repo_scans):
        """Successful responses use the success envelope format."""
        import json

        scan = _make_scan(scan_id="scan_env")
        repo_scans["scan_env"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_env")

        raw = json.loads(result.body)
        assert raw["success"] is True
        assert "data" in raw

    @pytest.mark.asyncio
    async def test_error_response_has_error_field(self):
        """Error responses include an error field."""
        import json

        result = await handle_get_scan_status(repo_id="empty-repo", scan_id="nonexistent")

        raw = json.loads(result.body)
        assert "error" in raw

    @pytest.mark.asyncio
    async def test_success_response_status_code_200(self, repo_scans):
        """Successful responses have status code 200."""
        scan = _make_scan(scan_id="scan_200")
        repo_scans["scan_200"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_200")

        assert result.status_code == 200

    @pytest.mark.asyncio
    async def test_error_response_status_code_404(self):
        """Not-found responses have status code 404."""
        result = await handle_get_scan_status(repo_id="empty-repo", scan_id="nonexistent")

        assert result.status_code == 404

    @pytest.mark.asyncio
    async def test_content_type_is_json(self, repo_scans):
        """Responses have application/json content type."""
        scan = _make_scan(scan_id="scan_ct")
        repo_scans["scan_ct"] = scan

        result = await handle_get_scan_status(repo_id="test-repo", scan_id="scan_ct")

        assert result.content_type == "application/json"
