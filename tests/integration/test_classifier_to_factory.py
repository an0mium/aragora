"""
Integration tests for classifier → debate_factory agent spec flow.

Verifies that agent specs generated by QuestionClassifier are correctly
parsed and processed by DebateFactory, ensuring the full pipeline works
end-to-end with the new pipe format.
"""

import pytest
from unittest.mock import Mock, patch, MagicMock

from aragora.server.question_classifier import (
    QuestionClassification,
    QuestionClassifier,
    classify_and_assign_agents_sync,
)
from aragora.server.debate_factory import (
    AgentSpec,
    DebateConfig,
    DebateFactory,
)
from aragora.agents.spec import VALID_ROLES


class TestClassifierToFactoryPipeline:
    """Integration tests for the classifier → factory pipeline."""

    def test_classifier_output_parseable_by_factory(self):
        """Classifier output should be parseable by DebateConfig."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="technical",
            complexity="moderate",
            recommended_personas=["claude", "qwen", "deepseek"],
        )

        # Get agent string from classifier
        agent_string = classifier.get_agent_string(classification)

        # Parse through DebateConfig
        config = DebateConfig(
            question="Test technical question",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()

        # Verify specs are valid
        assert len(specs) >= 2, "Should have at least 2 agents"
        for spec in specs:
            assert isinstance(spec, AgentSpec)
            assert spec.provider, f"Provider should not be empty: {spec}"
            assert spec.role in VALID_ROLES, f"Invalid role: {spec.role}"

    def test_classify_and_assign_e2e(self):
        """Full classify_and_assign → parse flow."""
        agent_string, classification = classify_and_assign_agents_sync(
            "How should we design a scalable microservices architecture?",
        )

        # Parse through DebateConfig
        config = DebateConfig(
            question="How should we design a scalable microservices architecture?",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()

        # Verify
        assert len(specs) >= 2
        assert classification.category in [
            "technical", "scientific", "general", "ethical",
            "financial", "healthcare", "legal", "security", "political",
        ]

        # Check all specs have valid roles
        roles_found = set()
        for spec in specs:
            assert spec.role in VALID_ROLES
            roles_found.add(spec.role)

        # Should have at least proposer and one other role for diverse debate
        assert "proposer" in roles_found, "Should have at least one proposer"

    def test_pipe_format_preserves_all_fields(self):
        """Pipe format should preserve model, persona, and role through the pipeline."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="ethical",
            complexity="complex",
            recommended_personas=["philosopher", "skeptic", "claude"],
        )

        agent_string = classifier.get_agent_string(classification)

        # Parse specs
        config = DebateConfig(
            question="Is AI consciousness possible?",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()

        # Verify personas are preserved
        personas_found = [spec.persona for spec in specs if spec.persona]
        assert len(personas_found) > 0, "Should preserve at least some personas"

    def test_role_rotation_produces_diverse_team(self):
        """Classifier should produce diverse roles for productive debate."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="technical",
            complexity="complex",
            recommended_personas=["claude", "qwen", "deepseek", "gemini"],
        )

        agent_string = classifier.get_agent_string(classification)
        config = DebateConfig(
            question="Database design question",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()

        # Collect roles
        roles = [spec.role for spec in specs]

        # Should have role diversity (not all same role)
        unique_roles = set(roles)
        assert len(unique_roles) >= 2, f"Should have role diversity, got: {roles}"

    @patch("aragora.server.debate_factory.create_agent")
    def test_factory_creates_agents_from_classifier_output(self, mock_create_agent):
        """DebateFactory should successfully create agents from classifier output."""
        # Setup mock agent
        mock_agent = MagicMock()
        mock_agent.api_key = "test-key"
        mock_create_agent.return_value = mock_agent

        # Get classifier output
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="security",
            complexity="moderate",
            recommended_personas=["security_engineer", "claude"],
        )
        agent_string = classifier.get_agent_string(classification)

        # Create factory and parse specs
        factory = DebateFactory()
        config = DebateConfig(
            question="Security review question",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()

        # Create agents
        result = factory.create_agents(specs)

        # Verify agents were created
        assert result.success_count >= 2, "Should create at least 2 agents"
        assert result.failure_count == 0, f"No failures expected, got: {result.failed}"

        # Verify create_agent was called with correct arguments
        for call in mock_create_agent.call_args_list:
            kwargs = call.kwargs
            assert "model_type" in kwargs
            assert "role" in kwargs
            assert kwargs["role"] in VALID_ROLES

    def test_legacy_colon_format_still_works(self):
        """Legacy agent:role format should still work through the pipeline."""
        # Use legacy colon format with explicit roles
        legacy_string = "anthropic-api:proposer,openai-api:critic,gemini:synthesizer"

        config = DebateConfig(
            question="Test with legacy format",
            agents_str=legacy_string,
        )
        specs = config.parse_agent_specs()

        assert len(specs) == 3
        roles = [spec.role for spec in specs]
        assert "proposer" in roles
        assert "critic" in roles
        assert "synthesizer" in roles

    def test_mixed_formats_work(self):
        """Mix of pipe and colon formats should work."""
        # Mix formats
        mixed_string = "anthropic-api|||proposer,openai-api:critic,gemini"

        config = DebateConfig(
            question="Test with mixed format",
            agents_str=mixed_string,
        )
        specs = config.parse_agent_specs()

        assert len(specs) == 3
        # First should be proposer (pipe format)
        assert specs[0].role == "proposer"
        # Second should be critic (colon format with role)
        assert specs[1].role == "critic"


class TestEdgeCases:
    """Edge case tests for the classifier → factory pipeline."""

    def test_single_persona_handled(self):
        """Single persona should still produce valid output."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="general",
            complexity="simple",
            recommended_personas=["claude"],
        )

        agent_string = classifier.get_agent_string(classification)

        # Should still be parseable (even if only 1 agent)
        # DebateConfig will raise if < 2 agents, but parsing should work
        from aragora.agents.spec import AgentSpec
        specs = AgentSpec.parse_list(agent_string)
        assert len(specs) >= 1

    def test_empty_personas_fallback(self):
        """Empty personas should use fallback."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="general",
            complexity="simple",
            recommended_personas=[],
        )

        agent_string = classifier.get_agent_string(classification)

        # Should produce some agents from fallback
        from aragora.agents.spec import AgentSpec
        specs = AgentSpec.parse_list(agent_string)
        # May be empty or have fallback - just verify no crash
        assert isinstance(specs, list)

    def test_unknown_persona_handled(self):
        """Unknown personas should map to default provider."""
        classifier = QuestionClassifier()
        classification = QuestionClassification(
            category="technical",
            complexity="moderate",
            recommended_personas=["nonexistent_persona", "claude"],
        )

        # Should not raise
        agent_string = classifier.get_agent_string(classification)

        # Should be parseable
        config = DebateConfig(
            question="Test",
            agents_str=agent_string,
        )
        specs = config.parse_agent_specs()
        assert len(specs) >= 1
