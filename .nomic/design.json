{
  "timestamp": "2026-01-01T08:06:27.691948",
  "improvement": "## Synthesis: The Single Best Improvement for Aragora NOW\n\nGiven that the original proposal failed due to environmental configuration (missing Gemini API key), I'll step into my role as synthesizer and propose what I believe would be most valuable based on my analysis of the codebase and recent changes.\n\n---\n\n### The Proposal: **Live Debate Viewer with Shareable Permalinks**\n\n**What it does:**\nA real-time web interface that visualizes multi-agent debates as they happen, generating unique shareable URLs for each debate session.\n\n**How it works:**\n1. Extends the existing `export/static_html.py` artifact export system\n2. Adds WebSocket streaming from `cli/run_debate.py` to push rounds in real-time\n3. Generates permalink slugs (e.g., `aragora.ai/debate/ai-alignment-2026-01-01`)\n4. Renders debates with agent \"avatars,\" consensus meters, and critique severity indicators\n5. One-click social sharing with auto-generated OG cards showing debate topic + participant models\n\n**Why it matters NOW:**\n- **Interesting**: Watch AI models argue in real-time is inherently compelling\n- **Powerful**: Leverages existing debate engine + export pipeline without new dependencies\n- **Viral**: Shareable links + visual OG cards = Twitter/HN/Reddit bait\n- **Useful**: Demonstrates aragora's value without requiring users to install anything\n\n**Implementation scope:**\n- ~300 lines Python (WebSocket server + permalink generation)\n- ~200 lines HTML/JS (viewer component)\n- Builds directly on recent work: `feat(export/pipeline)` and `feat(website)`\n\n---\n\n### Addressing the Critiques\n\n| Critique | Response |\n|----------|----------|\n| \"No concrete feature\" | Live Debate Viewer with specific modules identified |\n| \"No mechanism/scope\" | WebSocket streaming + static export extension, ~500 lines total |\n| \"Not aligned with roadmap\" | Directly extends `export/` work and `aragora.ai` positioning |\n| \"No impact justification\" | Viral sharing solves cold-start adoption; zero-install demos prove value |\n\n---\n\n### Why This Beats Alternatives\n\nOther reasonable proposals might include:\n- **Better voting/consensus UI** \u2192 Less viral, requires existing users\n- **More agent backends** \u2192 Diminishing returns (already have Qwen, Deepseek, Claude, Codex)\n- **Formal verification improvements** \u2192 Powerful but not viral\n- **Nomic loop enhancements** \u2192 Interesting but harder to demonstrate\n\nThe Live Debate Viewer maximizes *demonstrability* \u2014 the single biggest barrier to adoption for a project this novel. People need to **see** multi-agent debate to understand why it matters.\n\n---\n\n### Recommended Next Step\n\n```bash\n# Create the minimal viable viewer\npython scripts/debate.py --stream --output-html debate_live.html\n```\n\nStart with a static HTML export that refreshes, then add WebSocket streaming as a fast-follow.\n\n**Consensus recommendation: Implement the Live Debate Viewer with Shareable Permalinks.**",
  "design": "Now I have a complete understanding of the codebase. Let me synthesize the final implementation plan.\n\n---\n\n# Final Synthesis: Live Debate Viewer with Shareable Permalinks\n\n## Synthesis Reasoning\n\nAfter analyzing both proposals and the critiques, here's my synthesis:\n\n**What I'm keeping from the Architect's proposal:**\n- The `SyncEventEmitter` queue pattern solves the async/sync boundary elegantly\n- SQLite storage for permalinks is appropriate for v1\n- The phased implementation order is sensible\n\n**What I'm correcting based on Reviewer critiques:**\n1. **CLI structure**: The CLI uses subparsers correctly (`ask`, `demo`, `export`, `serve`). The proposal's approach aligns.\n2. **Arena integration**: Rather than deeply modifying `Arena.run()`, I'll use a simpler **callback injection** pattern that's less invasive\n3. **Data format**: The viewer uses flat `{agent, role, content, round}` - confirmed by reading `viewer.html`\n4. **Missing files**: Added `__init__.py` for server package\n\n**Simplifications I'm making:**\n- Removed OG image generation (can add later)\n- Simplified API to essential endpoints\n- Kept viewer changes minimal (~60 lines JS)\n\n---\n\n## 1. FILE CHANGES\n\n### New Files\n\n| File | Purpose | Lines (est.) |\n|------|---------|--------------|\n| `aragora/server/__init__.py` | Package initialization | 5 |\n| `aragora/server/stream.py` | WebSocket server + event emitter | 140 |\n| `aragora/server/storage.py` | SQLite permalink storage | 85 |\n| `aragora/server/api.py` | REST API for debate retrieval | 90 |\n\n### Modified Files\n\n| File | Changes |\n|------|---------|\n| `docs/viewer.html` | Add `LiveDebateConnection` class (~60 lines JS) |\n| `aragora/cli/main.py` | Add `serve` subcommand (~35 lines) |\n| `aragora/debate/orchestrator.py` | Add optional `event_hooks` dict parameter (~15 lines) |\n| `pyproject.toml` | Add `websockets>=12.0` dependency |\n\n**Total: ~430 lines new/modified code**\n\n---\n\n## 2. API DESIGN\n\n### 2.1 Event System (`aragora/server/stream.py`)\n\n```python\n\"\"\"Real-time debate streaming via WebSocket.\"\"\"\n\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Callable, Optional\nimport asyncio\nimport json\nimport queue\nimport time\n\n\nclass StreamEventType(Enum):\n    DEBATE_START = \"debate_start\"\n    ROUND_START = \"round_start\"\n    AGENT_MESSAGE = \"agent_message\"\n    CRITIQUE = \"critique\"\n    VOTE = \"vote\"\n    CONSENSUS = \"consensus\"\n    DEBATE_END = \"debate_end\"\n\n\n@dataclass\nclass StreamEvent:\n    type: StreamEventType\n    data: dict\n    timestamp: float\n    round: int = 0\n    agent: str = \"\"\n    \n    def to_dict(self) -> dict:\n        return {\n            \"type\": self.type.value,\n            \"data\": self.data,\n            \"timestamp\": self.timestamp,\n            \"round\": self.round,\n            \"agent\": self.agent,\n        }\n    \n    def to_json(self) -> str:\n        return json.dumps(self.to_dict())\n\n\nclass SyncEventEmitter:\n    \"\"\"\n    Thread-safe event emitter that bridges sync Arena code with async WebSocket.\n    \n    Events are queued synchronously and consumed by async broadcast task.\n    \"\"\"\n    \n    def __init__(self):\n        self._queue: queue.Queue[StreamEvent] = queue.Queue()\n        self._subscribers: list[Callable[[StreamEvent], None]] = []\n    \n    def emit(self, event: StreamEvent) -> None:\n        \"\"\"Emit event (safe from sync code).\"\"\"\n        self._queue.put(event)\n        for sub in self._subscribers:\n            try:\n                sub(event)\n            except Exception:\n                pass\n    \n    def subscribe(self, callback: Callable[[StreamEvent], None]) -> None:\n        \"\"\"Add synchronous subscriber.\"\"\"\n        self._subscribers.append(callback)\n    \n    def drain(self) -> list[StreamEvent]:\n        \"\"\"Get all queued events.\"\"\"\n        events = []\n        try:\n            while True:\n                events.append(self._queue.get_nowait())\n        except queue.Empty:\n            pass\n        return events\n\n\nclass DebateStreamServer:\n    \"\"\"WebSocket server broadcasting debate events.\"\"\"\n    \n    def __init__(self, host: str = \"localhost\", port: int = 8765):\n        self.host = host\n        self.port = port\n        self.clients: set = set()\n        self.current_debate: Optional[dict] = None\n        self._emitter = SyncEventEmitter()\n    \n    @property\n    def emitter(self) -> SyncEventEmitter:\n        return self._emitter\n    \n    async def broadcast(self, event: StreamEvent):\n        if self.clients:\n            message = event.to_json()\n            import websockets\n            await asyncio.gather(\n                *[c.send(message) for c in self.clients],\n                return_exceptions=True\n            )\n    \n    async def _drain_loop(self):\n        \"\"\"Background task draining emitter queue.\"\"\"\n        while True:\n            for event in self._emitter.drain():\n                await self.broadcast(event)\n            await asyncio.sleep(0.05)\n    \n    async def handler(self, websocket):\n        self.clients.add(websocket)\n        try:\n            if self.current_debate:\n                await websocket.send(json.dumps({\n                    \"type\": \"sync\", \"data\": self.current_debate\n                }))\n            async for _ in websocket:\n                pass  # Keep connection alive\n        finally:\n            self.clients.discard(websocket)\n    \n    async def start(self):\n        import websockets\n        asyncio.create_task(self._drain_loop())\n        async with websockets.serve(self.handler, self.host, self.port):\n            print(f\"WebSocket: ws://{self.host}:{self.port}\")\n            await asyncio.Future()\n\n\ndef create_arena_hooks(emitter: SyncEventEmitter) -> dict:\n    \"\"\"Create hook functions for Arena event emission.\"\"\"\n    \n    def on_debate_start(task: str, agents: list[str]):\n        emitter.emit(StreamEvent(\n            type=StreamEventType.DEBATE_START,\n            data={\"task\": task, \"agents\": agents},\n            timestamp=time.time()\n        ))\n    \n    def on_message(agent: str, content: str, role: str, round_num: int):\n        emitter.emit(StreamEvent(\n            type=StreamEventType.AGENT_MESSAGE,\n            data={\"content\": content, \"role\": role},\n            timestamp=time.time(),\n            round=round_num,\n            agent=agent\n        ))\n    \n    def on_critique(agent: str, target: str, severity: float, round_num: int):\n        emitter.emit(StreamEvent(\n            type=StreamEventType.CRITIQUE,\n            data={\"target\": target, \"severity\": severity},\n            timestamp=time.time(),\n            round=round_num,\n            agent=agent\n        ))\n    \n    def on_consensus(reached: bool, confidence: float, answer: str):\n        emitter.emit(StreamEvent(\n            type=StreamEventType.CONSENSUS,\n            data={\"reached\": reached, \"confidence\": confidence, \n                  \"answer\": answer[:500]},\n            timestamp=time.time()\n        ))\n    \n    def on_debate_end(duration: float, rounds: int):\n        emitter.emit(StreamEvent(\n            type=StreamEventType.DEBATE_END,\n            data={\"duration\": duration, \"rounds\": rounds},\n            timestamp=time.time()\n        ))\n    \n    return {\n        \"on_debate_start\": on_debate_start,\n        \"on_message\": on_message,\n        \"on_critique\": on_critique,\n        \"on_consensus\": on_consensus,\n        \"on_debate_end\": on_debate_end,\n    }\n```\n\n### 2.2 Storage (`aragora/server/storage.py`)\n\n```python\n\"\"\"SQLite-backed debate storage with permalink generation.\"\"\"\n\nimport json\nimport sqlite3\nimport re\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Optional\n\n\n@dataclass\nclass DebateMetadata:\n    slug: str\n    debate_id: str\n    task: str\n    agents: list[str]\n    consensus_reached: bool\n    created_at: datetime\n    view_count: int = 0\n\n\nclass DebateStorage:\n    \"\"\"Debate persistence with shareable permalinks.\"\"\"\n    \n    def __init__(self, db_path: str = \"aragora_debates.db\"):\n        self.db_path = Path(db_path)\n        self._init_db()\n    \n    def _init_db(self):\n        conn = sqlite3.connect(self.db_path)\n        conn.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS debates (\n                id TEXT PRIMARY KEY,\n                slug TEXT UNIQUE NOT NULL,\n                task TEXT NOT NULL,\n                agents TEXT NOT NULL,\n                artifact_json TEXT NOT NULL,\n                consensus_reached BOOLEAN,\n                confidence REAL,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                view_count INTEGER DEFAULT 0\n            )\n        \"\"\")\n        conn.execute(\"CREATE INDEX IF NOT EXISTS idx_slug ON debates(slug)\")\n        conn.commit()\n        conn.close()\n    \n    def generate_slug(self, task: str) -> str:\n        \"\"\"Generate URL-friendly slug from task.\"\"\"\n        words = re.sub(r'[^\\w\\s]', '', task.lower()).split()\n        stop_words = {'a', 'an', 'the', 'is', 'are', 'for', 'to', 'of', 'and'}\n        key_words = [w for w in words if w not in stop_words][:4]\n        base = '-'.join(key_words) or 'debate'\n        date = datetime.now().strftime('%Y-%m-%d')\n        slug = f\"{base}-{date}\"\n        \n        # Handle collisions\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.execute(\n            \"SELECT COUNT(*) FROM debates WHERE slug LIKE ?\", (f\"{slug}%\",)\n        )\n        count = cursor.fetchone()[0]\n        conn.close()\n        \n        return f\"{slug}-{count + 1}\" if count > 0 else slug\n    \n    def save(self, artifact) -> str:\n        \"\"\"Save artifact, return permalink slug.\"\"\"\n        slug = self.generate_slug(artifact.task)\n        \n        conn = sqlite3.connect(self.db_path)\n        conn.execute(\"\"\"\n            INSERT INTO debates (id, slug, task, agents, artifact_json,\n                                consensus_reached, confidence)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        \"\"\", (\n            artifact.artifact_id,\n            slug,\n            artifact.task,\n            json.dumps(artifact.agents),\n            artifact.to_json(),\n            artifact.consensus_proof.reached if artifact.consensus_proof else False,\n            artifact.consensus_proof.confidence if artifact.consensus_proof else 0,\n        ))\n        conn.commit()\n        conn.close()\n        return slug\n    \n    def get_by_slug(self, slug: str) -> Optional[dict]:\n        \"\"\"Get debate by slug, increment view count.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.execute(\n            \"SELECT artifact_json FROM debates WHERE slug = ?\", (slug,)\n        )\n        row = cursor.fetchone()\n        if row:\n            conn.execute(\n                \"UPDATE debates SET view_count = view_count + 1 WHERE slug = ?\",\n                (slug,)\n            )\n            conn.commit()\n        conn.close()\n        return json.loads(row[0]) if row else None\n    \n    def list_recent(self, limit: int = 20) -> list[DebateMetadata]:\n        \"\"\"List recent debates.\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.execute(\"\"\"\n            SELECT slug, id, task, agents, consensus_reached, created_at, view_count\n            FROM debates ORDER BY created_at DESC LIMIT ?\n        \"\"\", (limit,))\n        \n        results = [\n            DebateMetadata(\n                slug=r[0], debate_id=r[1], task=r[2],\n                agents=json.loads(r[3]), consensus_reached=bool(r[4]),\n                created_at=datetime.fromisoformat(r[5]), view_count=r[6]\n            )\n            for r in cursor.fetchall()\n        ]\n        conn.close()\n        return results\n```\n\n### 2.3 REST API (`aragora/server/api.py`)\n\n```python\n\"\"\"HTTP API for debate retrieval.\"\"\"\n\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nfrom urllib.parse import urlparse\nfrom pathlib import Path\nimport json\n\n\nclass DebateAPIHandler(BaseHTTPRequestHandler):\n    storage = None\n    static_dir = None\n    \n    def do_GET(self):\n        parsed = urlparse(self.path)\n        \n        if parsed.path.startswith('/api/debates/'):\n            slug = parsed.path.split('/')[-1]\n            self._get_debate(slug)\n        elif parsed.path == '/api/debates':\n            self._list_debates()\n        elif parsed.path in ('/', '/viewer.html'):\n            self._serve_viewer()\n        else:\n            self.send_error(404)\n    \n    def _get_debate(self, slug: str):\n        debate = self.storage.get_by_slug(slug)\n        if debate:\n            self._json(debate)\n        else:\n            self.send_error(404, f\"Debate not found: {slug}\")\n    \n    def _list_debates(self):\n        debates = self.storage.list_recent(20)\n        self._json([{\n            \"slug\": d.slug,\n            \"task\": d.task[:100],\n            \"agents\": d.agents,\n            \"consensus\": d.consensus_reached,\n            \"views\": d.view_count,\n        } for d in debates])\n    \n    def _serve_viewer(self):\n        if self.static_dir:\n            viewer = self.static_dir / \"viewer.html\"\n            if viewer.exists():\n                self.send_response(200)\n                self.send_header('Content-Type', 'text/html')\n                self.end_headers()\n                self.wfile.write(viewer.read_bytes())\n                return\n        self.send_error(404)\n    \n    def _json(self, data):\n        self.send_response(200)\n        self.send_header('Content-Type', 'application/json')\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.end_headers()\n        self.wfile.write(json.dumps(data).encode())\n    \n    def log_message(self, *args):\n        pass\n\n\ndef run_api_server(storage, port: int = 8080, static_dir: Path = None):\n    DebateAPIHandler.storage = storage\n    DebateAPIHandler.static_dir = static_dir\n    server = HTTPServer(('', port), DebateAPIHandler)\n    print(f\"API: http://localhost:{port}\")\n    server.serve_forever()\n```\n\n### 2.4 Arena Integration (Minimal Change to `orchestrator.py`)\n\n```python\n# Add to Arena.__init__:\ndef __init__(\n    self,\n    environment: Environment,\n    agents: list[Agent],\n    protocol: DebateProtocol = None,\n    memory=None,\n    event_hooks: dict = None,  # NEW\n):\n    # ... existing code ...\n    self.hooks = event_hooks or {}\n\n# Add hook calls at key points in run():\n\n# After \"DEBATE:\" print (line ~100):\nif \"on_debate_start\" in self.hooks:\n    self.hooks[\"on_debate_start\"](self.env.task, [a.name for a in self.agents])\n\n# After each message is appended to result.messages:\nif \"on_message\" in self.hooks:\n    self.hooks[\"on_message\"](\n        agent=agent.name,\n        content=proposals[agent.name],\n        role=\"proposer\",\n        round_num=0\n    )\n\n# After critique is appended (inside critique loop):\nif \"on_critique\" in self.hooks:\n    self.hooks[\"on_critique\"](\n        agent=critic.name,\n        target=proposal_agent,\n        severity=crit_result.severity,\n        round_num=round_num\n    )\n\n# After consensus determination:\nif \"on_consensus\" in self.hooks:\n    self.hooks[\"on_consensus\"](\n        reached=result.consensus_reached,\n        confidence=result.confidence,\n        answer=result.final_answer\n    )\n\n# At end before return:\nif \"on_debate_end\" in self.hooks:\n    self.hooks[\"on_debate_end\"](result.duration_seconds, result.rounds_used)\n```\n\n### 2.5 CLI Integration (Add to `main.py`)\n\n```python\ndef cmd_serve(args):\n    \"\"\"Run live debate server.\"\"\"\n    import asyncio\n    import threading\n    from pathlib import Path\n    from aragora.server.stream import DebateStreamServer\n    from aragora.server.api import run_api_server\n    from aragora.server.storage import DebateStorage\n    \n    storage = DebateStorage(args.db)\n    docs_dir = Path(__file__).parent.parent.parent / \"docs\"\n    \n    print(f\"\\n{'='*60}\")\n    print(\"ARAGORA LIVE DEBATE SERVER\")\n    print(f\"{'='*60}\")\n    print(f\"WebSocket: ws://localhost:{args.ws_port}\")\n    print(f\"API:       http://localhost:{args.api_port}\")\n    print(f\"Viewer:    http://localhost:{args.api_port}/viewer.html?live=true\")\n    print(f\"{'='*60}\\n\")\n    \n    stream_server = DebateStreamServer(port=args.ws_port)\n    \n    async def run():\n        threading.Thread(\n            target=run_api_server,\n            args=(storage, args.api_port, docs_dir),\n            daemon=True\n        ).start()\n        await stream_server.start()\n    \n    asyncio.run(run())\n\n# Add to main() subparsers:\nserve_parser = subparsers.add_parser(\"serve\", help=\"Run live debate server\")\nserve_parser.add_argument(\"--ws-port\", type=int, default=8765)\nserve_parser.add_argument(\"--api-port\", type=int, default=8080)\nserve_parser.add_argument(\"--db\", default=\"aragora_debates.db\")\nserve_parser.set_defaults(func=cmd_serve)\n```\n\n### 2.6 Viewer Update (Add to `docs/viewer.html`)\n\n```javascript\n// Add after line 735 (after DEMO_DEBATE definition):\n\nclass LiveDebateConnection {\n    constructor(wsUrl = 'ws://localhost:8765') {\n        this.wsUrl = wsUrl;\n        this.ws = null;\n        this.reconnectAttempts = 0;\n    }\n    \n    connect() {\n        this.ws = new WebSocket(this.wsUrl);\n        this.ws.onopen = () => {\n            this.reconnectAttempts = 0;\n            this.updateStatus('live');\n        };\n        this.ws.onmessage = (e) => this.handleEvent(JSON.parse(e.data));\n        this.ws.onclose = () => {\n            this.updateStatus('disconnected');\n            if (this.reconnectAttempts < 5) {\n                setTimeout(() => {\n                    this.reconnectAttempts++;\n                    this.connect();\n                }, 2000 * this.reconnectAttempts);\n            }\n        };\n    }\n    \n    handleEvent(event) {\n        switch (event.type) {\n            case 'debate_start':\n                debateData = {\n                    id: `live-${Date.now()}`,\n                    task: event.data.task,\n                    agents: event.data.agents.map(name => ({\n                        name, model: name.split('_')[0], role: 'proposer'\n                    })),\n                    messages: [],\n                    consensus_reached: false,\n                    confidence: 0,\n                    rounds: 0,\n                    duration_seconds: 0,\n                    created_at: new Date().toISOString()\n                };\n                renderDebate();\n                break;\n            case 'agent_message':\n                const msg = {\n                    agent: event.agent,\n                    role: event.data.role,\n                    round: event.round,\n                    content: event.data.content\n                };\n                debateData.messages.push(msg);\n                debateData.rounds = Math.max(debateData.rounds, event.round);\n                this.appendMessage(msg);\n                break;\n            case 'consensus':\n                debateData.consensus_reached = event.data.reached;\n                debateData.confidence = event.data.confidence;\n                debateData.final_answer = event.data.answer;\n                const badge = document.getElementById('consensus-badge');\n                if (event.data.reached) {\n                    badge.className = 'consensus-badge reached';\n                    badge.innerHTML = `&#10003; Consensus (${Math.round(event.data.confidence * 100)}%)`;\n                }\n                if (event.data.answer) {\n                    document.getElementById('final-answer').style.display = 'block';\n                    document.getElementById('final-answer-content').textContent = event.data.answer;\n                }\n                break;\n            case 'debate_end':\n                this.updateStatus('ended');\n                break;\n            case 'sync':\n                debateData = event.data;\n                renderDebate();\n                break;\n        }\n    }\n    \n    appendMessage(msg) {\n        const feed = document.getElementById('debate-feed');\n        const provider = getProvider(msg.agent);\n        const div = document.createElement('div');\n        div.className = `message ${provider} visible`;\n        div.dataset.index = debateData.messages.length - 1;\n        div.innerHTML = `\n            <div class=\"message-header\">\n                <div class=\"agent-name\">\n                    <div class=\"avatar\">${provider[0].toUpperCase()}</div>\n                    ${escapeHtml(msg.agent)}\n                </div>\n                <div class=\"meta-info\">\n                    <span class=\"role-badge ${msg.role}\">${msg.role}</span>\n                    <span>Round ${msg.round}</span>\n                </div>\n            </div>\n            <div class=\"message-content\">${escapeHtml(msg.content)}</div>\n        `;\n        feed.appendChild(div);\n        div.scrollIntoView({ behavior: 'smooth', block: 'end' });\n        \n        const slider = document.getElementById('timeline-slider');\n        slider.max = debateData.messages.length - 1;\n        slider.value = debateData.messages.length - 1;\n        currentStep = debateData.messages.length - 1;\n    }\n    \n    updateStatus(status) {\n        let ind = document.getElementById('live-indicator');\n        if (!ind) {\n            ind = document.createElement('div');\n            ind.id = 'live-indicator';\n            ind.style.cssText = 'display:inline-flex;align-items:center;padding:0.3rem 0.8rem;border-radius:1rem;font-size:0.8rem;font-weight:600;margin-left:1rem;';\n            document.querySelector('header h1')?.appendChild(ind);\n        }\n        ind.style.background = status === 'live' ? 'rgba(239,68,68,0.2)' : \n                               status === 'ended' ? 'rgba(34,197,94,0.2)' : 'rgba(156,163,175,0.2)';\n        ind.style.color = status === 'live' ? '#ef4444' : \n                          status === 'ended' ? '#22c55e' : '#9ca3af';\n        ind.textContent = status === 'live' ? '\u25cf LIVE' : \n                          status === 'ended' ? '\u25cf ENDED' : '\u25cb Reconnecting...';\n    }\n}\n\n// Initialize live mode\nconst params = new URLSearchParams(window.location.search);\nif (params.get('live') === 'true') {\n    const wsPort = params.get('ws') || '8765';\n    new LiveDebateConnection(`ws://localhost:${wsPort}`).connect();\n}\n```\n\n---\n\n## 3. INTEGRATION\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Data Flow Architecture                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nLIVE STREAMING:\n  aragora ask --task \"...\" --stream\n       \u2502\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502   Arena     \u2502\u2500\u2500\u2500\u2500\u25b6\u2502  event_hooks     \u2502\n  \u2502   .run()    \u2502     \u2502  (sync calls)    \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502 SyncEventEmitter \u2502\n                      \u2502   ._queue        \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502  drain_loop()    \u2502\n                      \u2502  (async task)    \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n                               \u25bc\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                      \u2502  WebSocket       \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 viewer.html?live=true\n                      \u2502  broadcast()     \u2502\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nPERMALINK SHARING:\n  After debate completes:\n       \u2502\n       \u25bc\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 ArtifactBuilder \u2502\u2500\u2500\u2500\u2500\u25b6\u2502 DebateStorage\u2502\n  \u2502   .build()      \u2502     \u2502  .save()     \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                  \u2502\n                                  \u25bc\n                          slug: \"rate-limiter-2026-01-01\"\n                                  \u2502\n                                  \u25bc\n                      https://aragora.ai/viewer.html?id={slug}\n```\n\n---\n\n## 4. TEST PLAN\n\n### Unit Tests\n\n```python\n# tests/test_server_stream.py\ndef test_sync_emitter_queues_events():\n    emitter = SyncEventEmitter()\n    event = StreamEvent(type=StreamEventType.DEBATE_START, data={}, timestamp=0)\n    emitter.emit(event)\n    assert len(emitter.drain()) == 1\n\ndef test_event_serialization():\n    event = StreamEvent(\n        type=StreamEventType.AGENT_MESSAGE,\n        data={\"content\": \"test\", \"role\": \"proposer\"},\n        timestamp=0, round=1, agent=\"claude\"\n    )\n    d = event.to_dict()\n    assert d[\"type\"] == \"agent_message\"\n    assert d[\"agent\"] == \"claude\"\n\n# tests/test_server_storage.py  \ndef test_slug_generation(tmp_path):\n    storage = DebateStorage(str(tmp_path / \"test.db\"))\n    slug = storage.generate_slug(\"Design a rate limiter\")\n    assert \"rate\" in slug or \"limiter\" in slug\n    assert \"-202\" in slug  # Date portion\n\ndef test_save_and_retrieve(tmp_path):\n    storage = DebateStorage(str(tmp_path / \"test.db\"))\n    # Create minimal artifact...\n    slug = storage.save(artifact)\n    retrieved = storage.get_by_slug(slug)\n    assert retrieved[\"task\"] == artifact.task\n```\n\n### Integration Test\n\n```python\n# tests/test_live_debate.py\n@pytest.mark.asyncio\nasync def test_arena_emits_events():\n    emitter = SyncEventEmitter()\n    hooks = create_arena_hooks(emitter)\n    received = []\n    emitter.subscribe(lambda e: received.append(e.type.value))\n    \n    # Run minimal debate with mock agents\n    env = Environment(task=\"Test\", max_rounds=1)\n    agents = [create_agent(\"mock\", name=\"a\", role=\"proposer\")]\n    arena = Arena(env, agents, event_hooks=hooks)\n    await arena.run()\n    \n    assert \"debate_start\" in received\n    assert \"agent_message\" in received\n```\n\n### E2E Test Script\n\n```bash\n#!/bin/bash\n# Start server\npython -m aragora.cli.main serve &\nSERVER_PID=$!\nsleep 2\n\n# Check WebSocket (requires wscat)\necho \"Testing WebSocket...\"\ntimeout 5 wscat -c ws://localhost:8765 || echo \"WebSocket OK\"\n\n# Check API\necho \"Testing API...\"\ncurl -s http://localhost:8080/api/debates | jq '.'\n\nkill $SERVER_PID\n```\n\n---\n\n## 5. EXAMPLE USAGE\n\n### Start Server\n```bash\n$ aragora serve\n============================================================\nARAGORA LIVE DEBATE SERVER\n============================================================\nWebSocket: ws://localhost:8765\nAPI:       http://localhost:8080\nViewer:    http://localhost:8080/viewer.html?live=true\n============================================================\n```\n\n### Run Streaming Debate\n```bash\n$ aragora ask \"Design a cache invalidation strategy\" \\\n    --agents codex,claude --rounds 2\n\n# Open browser: http://localhost:8080/viewer.html?live=true\n# Watch debate unfold in real-time\n```\n\n### Share Completed Debate\n```python\nfrom aragora.export.artifact import ArtifactBuilder\nfrom aragora.server.storage import DebateStorage\n\nartifact = ArtifactBuilder().from_result(result).build()\nslug = DebateStorage().save(artifact)\nprint(f\"Share: https://aragora.ai/viewer.html?id={slug}\")\n# \u2192 https://aragora.ai/viewer.html?id=cache-invalidation-2026-01-01\n```\n\n### Fetch via API\n```bash\ncurl https://aragora.ai/api/debates/cache-invalidation-2026-01-01\n```\n\n---\n\n## 6. IMPLEMENTATION ORDER\n\n1. **Phase 1: Stream Infrastructure** (~145 lines)\n   - `aragora/server/__init__.py`\n   - `aragora/server/stream.py`\n   - Test: Unit tests for emitter/events\n\n2. **Phase 2: Arena Hooks** (~15 lines)\n   - Modify `orchestrator.py` to accept `event_hooks`\n   - Test: Arena emits events when hooks provided\n\n3. **Phase 3: Storage + API** (~175 lines)\n   - `aragora/server/storage.py`\n   - `aragora/server/api.py`\n   - Test: Save/retrieve debates, API endpoints\n\n4. **Phase 4: Viewer Update** (~60 lines)\n   - Add `LiveDebateConnection` to `viewer.html`\n   - Test: Connect, receive events, render\n\n5. **Phase 5: CLI** (~35 lines)\n   - Add `serve` subcommand to `main.py`\n   - Test: Full e2e flow\n\n---\n\n## 7. DEPENDENCIES\n\n```toml\n# Add to pyproject.toml [project.dependencies]\nwebsockets = \">=12.0\"\n```\n\n---\n\n## Summary\n\nThis synthesis addresses all critical issues raised:\n\n| Issue | Resolution |\n|-------|------------|\n| CLI structure | Uses existing subparser pattern (`serve` alongside `ask`, `demo`, etc.) |\n| Async/sync boundary | `SyncEventEmitter` with queue + async drain loop |\n| Data format mismatch | Viewer receives flat `{agent, role, content, round}` structure |\n| Missing `__init__.py` | Included in file list |\n| Invasive Arena changes | Minimal ~15 lines with optional `event_hooks` dict |\n\nThe implementation is **~430 lines total**, delivers the core viral sharing capability, and builds directly on existing infrastructure (`viewer.html`, `export/artifact.py`, CLI subparsers).",
  "consensus_reached": true
}