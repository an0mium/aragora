"""
HTTP API handlers for dependency vulnerability scanning.

Provides handlers for:
- Trigger dependency vulnerability scans
- Query CVE databases
- Get scan results and history
- View vulnerability details
"""

from __future__ import annotations

import asyncio
import logging
import uuid
from datetime import datetime, timezone

from aragora.analysis.codebase import CVEClient, ScanResult
from aragora.server.handlers.base import (
    HandlerResult,
    error_response,
    require_permission,
    success_response,
)

from .events import emit_scan_events
from .storage import (
    get_or_create_repo_scans,
    get_running_scans,
    get_scan_lock,
    get_scanner,
)

logger = logging.getLogger(__name__)
_BASE_CVECLIENT = CVEClient


def _get_cve_client_cls() -> type:
    """Resolve CVEClient class, honoring test patching at multiple import paths."""
    if CVEClient is not _BASE_CVECLIENT:
        return CVEClient
    try:
        from aragora.server.handlers.codebase import security as security_module

        patched = getattr(security_module, "CVEClient", _BASE_CVECLIENT)
        if patched is not _BASE_CVECLIENT:
            return patched
    except (ImportError, AttributeError, TypeError) as e:
        logger.debug("Failed to resolve CVEClient override: %s", e)
    return _BASE_CVECLIENT


@require_permission("security:scan")
async def handle_scan_repository(
    repo_path: str,
    repo_id: str | None = None,
    branch: str | None = None,
    commit_sha: str | None = None,
    workspace_id: str | None = None,
    user_id: str | None = None,
) -> HandlerResult:
    """
    Trigger a security scan for a repository.

    POST /api/v1/codebase/{repo}/scan
    {
        "repo_path": "/path/to/repo",
        "branch": "main",
        "commit_sha": "abc123"
    }
    """
    try:
        repo_id = repo_id or f"repo_{uuid.uuid4().hex[:12]}"
        scan_id = f"scan_{uuid.uuid4().hex[:12]}"

        running_scans = get_running_scans()
        scan_lock = get_scan_lock()

        # Check if scan already running
        if repo_id in running_scans:
            task = running_scans[repo_id]
            if not task.done():
                return error_response("Scan already in progress", 409)

        # Create initial scan result
        scan_result = ScanResult(
            scan_id=scan_id,
            repository=repo_id,
            branch=branch,
            commit_sha=commit_sha,
            status="running",
        )

        repo_scans = get_or_create_repo_scans(repo_id)
        repo_scans[scan_id] = scan_result

        # Start async scan
        async def run_scan() -> None:
            try:
                scanner = get_scanner()
                result = await scanner.scan_repository(
                    repo_path=repo_path,
                    branch=branch,
                    commit_sha=commit_sha,
                )

                # Update stored result
                with scan_lock:
                    repo_scans[scan_id] = result
                    result.scan_id = scan_id

                summary = getattr(result, "summary", result)
                vuln_count = getattr(summary, "vulnerable_dependencies", 0)
                logger.info(
                    f"[Security] Completed scan {scan_id} for {repo_id}: "
                    f"{vuln_count} vulnerable deps found"
                )

                # Emit security events for findings (triggers debate for critical findings)
                await emit_scan_events(result, repo_id, scan_id, workspace_id)

            except (OSError, ValueError, TypeError, RuntimeError) as e:
                logger.exception(f"Scan {scan_id} failed: {e}")
                with scan_lock:
                    scan_result.status = "failed"
                    scan_result.error = "Vulnerability scan failed"
                    scan_result.completed_at = datetime.now(timezone.utc)

            finally:
                if repo_id in running_scans:
                    del running_scans[repo_id]

        # Create and store task
        task = asyncio.create_task(run_scan())
        running_scans[repo_id] = task

        logger.info(f"[Security] Started scan {scan_id} for {repo_id}")

        return success_response(
            {
                "scan_id": scan_id,
                "status": "running",
                "repository": repo_id,
            }
        )

    except (OSError, ValueError, TypeError, RuntimeError) as e:
        logger.exception(f"Failed to start scan: {e}")
        return error_response("Internal server error", 500)


@require_permission("security:read")
async def handle_get_scan_status(
    repo_id: str,
    scan_id: str | None = None,
) -> HandlerResult:
    """
    Get scan status/result.

    GET /api/v1/codebase/{repo}/scan/latest
    GET /api/v1/codebase/{repo}/scan/{scan_id}
    """
    try:
        repo_scans = get_or_create_repo_scans(repo_id)

        if scan_id:
            # Get specific scan
            scan = repo_scans.get(scan_id)
            if not scan:
                return error_response("Scan not found", 404)
            return success_response({"scan_result": scan.to_dict()})
        else:
            # Get latest scan
            if not repo_scans:
                return error_response("No scans found for repository", 404)

            # Sort by start time and get latest
            latest = max(repo_scans.values(), key=lambda s: s.started_at)
            return success_response({"scan_result": latest.to_dict()})

    except (KeyError, ValueError, TypeError) as e:
        logger.exception(f"Failed to get scan status: {e}")
        return error_response("Internal server error", 500)


@require_permission("security:read")
async def handle_get_vulnerabilities(
    repo_id: str,
    severity: str | None = None,
    package: str | None = None,
    ecosystem: str | None = None,
    limit: int = 100,
    offset: int = 0,
) -> HandlerResult:
    """
    Get vulnerabilities from latest scan.

    GET /api/v1/codebase/{repo}/vulnerabilities
    Query params: severity, package, ecosystem, limit, offset
    """
    try:
        repo_scans = get_or_create_repo_scans(repo_id)

        if not repo_scans:
            return error_response("No scans found for repository", 404)

        # Get latest completed scan
        completed_scans = [s for s in repo_scans.values() if s.status == "completed"]
        if not completed_scans:
            return error_response("No completed scans found", 404)

        latest = max(completed_scans, key=lambda s: s.started_at)

        # Collect all vulnerabilities
        vulnerabilities = []
        for dep in latest.dependencies:
            for vuln in dep.vulnerabilities:
                vuln_dict = vuln.to_dict()
                vuln_dict["package_name"] = dep.name
                vuln_dict["package_version"] = dep.version
                vuln_dict["package_ecosystem"] = dep.ecosystem
                vulnerabilities.append(vuln_dict)

        # Filter
        if severity:
            vulnerabilities = [v for v in vulnerabilities if v["severity"] == severity]
        if package:
            vulnerabilities = [
                v for v in vulnerabilities if package.lower() in v["package_name"].lower()
            ]
        if ecosystem:
            vulnerabilities = [v for v in vulnerabilities if v["package_ecosystem"] == ecosystem]

        # Sort by severity
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "unknown": 4}
        vulnerabilities.sort(key=lambda v: severity_order.get(v["severity"], 5))

        # Paginate
        total = len(vulnerabilities)
        vulnerabilities = vulnerabilities[offset : offset + limit]

        return success_response(
            {
                "vulnerabilities": vulnerabilities,
                "total": total,
                "limit": limit,
                "offset": offset,
                "scan_id": latest.scan_id,
            }
        )

    except (KeyError, ValueError, TypeError, AttributeError) as e:
        logger.exception(f"Failed to get vulnerabilities: {e}")
        return error_response("Internal server error", 500)


@require_permission("security:read")
async def handle_get_cve_details(
    cve_id: str,
) -> HandlerResult:
    """
    Get CVE details from vulnerability databases.

    GET /api/v1/cve/{cve_id}
    """
    try:
        client_cls = _get_cve_client_cls()
        client = client_cls()
        vuln = await client.get_cve(cve_id)

        if not vuln:
            return error_response(f"CVE {cve_id} not found", 404)

        data = vuln.to_dict()
        if "cve_id" not in data:
            data = {"cve_id": cve_id, **data}
        return success_response({"vulnerability": data})

    except (OSError, ValueError, KeyError, RuntimeError, asyncio.TimeoutError) as e:
        logger.exception(f"Failed to get CVE details: {e}")
        return error_response("Internal server error", 500)


@require_permission("security:read")
async def handle_query_package_vulnerabilities(
    package_name: str,
    ecosystem: str,
    version: str | None = None,
) -> HandlerResult:
    """
    Query vulnerabilities for a specific package.

    GET /api/v1/codebase/package/{ecosystem}/{package}/vulnerabilities
    """
    try:
        client_cls = _get_cve_client_cls()
        client = client_cls()
        vulnerabilities = await client.query_package(
            package_name=package_name,
            ecosystem=ecosystem,
            version=version,
        )

        return success_response(
            {
                "package": package_name,
                "ecosystem": ecosystem,
                "version": version,
                "vulnerabilities": [v.to_dict() for v in vulnerabilities],
                "total": len(vulnerabilities),
            }
        )

    except (OSError, ValueError, KeyError, RuntimeError, asyncio.TimeoutError) as e:
        logger.exception(f"Failed to query package vulnerabilities: {e}")
        return error_response("Internal server error", 500)


@require_permission("security:read")
async def handle_list_scans(
    repo_id: str,
    status: str | None = None,
    limit: int = 20,
    offset: int = 0,
) -> HandlerResult:
    """
    List scan history for a repository.

    GET /api/v1/codebase/{repo}/scans
    """
    try:
        repo_scans = get_or_create_repo_scans(repo_id)

        scans = list(repo_scans.values())

        # Filter by status
        if status:
            scans = [s for s in scans if s.status == status]

        # Sort by start time descending
        scans.sort(key=lambda s: s.started_at, reverse=True)

        # Paginate
        total = len(scans)
        scans = scans[offset : offset + limit]

        return success_response(
            {
                "scans": [
                    {
                        "scan_id": s.scan_id,
                        "status": s.status,
                        "started_at": s.started_at.isoformat(),
                        "completed_at": s.completed_at.isoformat() if s.completed_at else None,
                        "summary": (
                            {
                                "total_dependencies": s.total_dependencies,
                                "vulnerable_dependencies": s.vulnerable_dependencies,
                                "critical_count": s.critical_count,
                                "high_count": s.high_count,
                                "medium_count": s.medium_count,
                                "low_count": s.low_count,
                            }
                            if s.status == "completed"
                            else None
                        ),
                    }
                    for s in scans
                ],
                "total": total,
                "limit": limit,
                "offset": offset,
            }
        )

    except (KeyError, ValueError, TypeError) as e:
        logger.exception(f"Failed to list scans: {e}")
        return error_response("Internal server error", 500)
