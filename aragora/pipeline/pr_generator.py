"""
PR Generator - Transform debate outcomes into Pull Request artifacts.

Generates structured artifacts from debate consensus:
- DecisionMemo: What was decided and why
- PatchPlan: Step-by-step implementation guide

Usage:
    generator = PRGenerator(artifact)
    memo = generator.generate_decision_memo()
    plan = generator.generate_patch_plan()
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any

from aragora.export.artifact import DebateArtifact


@dataclass
class DecisionMemo:
    """
    Summary of debate conclusions for stakeholder communication.

    Contains the key decisions, rationale, and supporting evidence
    from a completed debate.
    """

    debate_id: str
    title: str
    summary: str
    key_decisions: list[str]
    rationale: str
    supporting_evidence: list[dict]
    dissenting_views: list[str]
    open_questions: list[str]
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())

    # Metrics
    consensus_confidence: float = 0.0
    rounds_used: int = 0
    agent_count: int = 0

    def to_markdown(self) -> str:
        """Generate markdown representation."""
        decisions_md = "\n".join(f"- {d}" for d in self.key_decisions)
        evidence_md = "\n".join(
            f"- [{e.get('source', 'Unknown')}] {e.get('summary', '')[:100]}"
            for e in self.supporting_evidence[:5]
        )
        dissenting_md = (
            "\n".join(f"- {v}" for v in self.dissenting_views)
            if self.dissenting_views
            else "*None recorded*"
        )
        questions_md = (
            "\n".join(f"- {q}" for q in self.open_questions) if self.open_questions else "*None*"
        )

        return f"""# Decision Memo: {self.title}

**Debate ID:** {self.debate_id}
**Date:** {self.created_at[:10]}
**Consensus:** {self.consensus_confidence:.0%} confidence after {self.rounds_used} rounds

---

## Summary

{self.summary}

---

## Key Decisions

{decisions_md}

---

## Rationale

{self.rationale}

---

## Supporting Evidence

{evidence_md}

---

## Dissenting Views

{dissenting_md}

---

## Open Questions

{questions_md}

---

*Generated by aragora v0.8.0*
"""

    def to_dict(self) -> dict:
        return {
            "debate_id": self.debate_id,
            "title": self.title,
            "summary": self.summary,
            "key_decisions": self.key_decisions,
            "rationale": self.rationale,
            "supporting_evidence": self.supporting_evidence,
            "dissenting_views": self.dissenting_views,
            "open_questions": self.open_questions,
            "created_at": self.created_at,
            "consensus_confidence": self.consensus_confidence,
            "rounds_used": self.rounds_used,
            "agent_count": self.agent_count,
        }


@dataclass
class PatchPlan:
    """
    Step-by-step implementation plan from debate conclusions.

    Provides actionable steps for implementing the debated solution,
    including file changes, dependencies, and verification steps.
    """

    debate_id: str
    title: str
    description: str
    steps: list[dict]  # [{step_num, action, target, details, verification}]
    file_changes: list[dict]  # [{path, action, description}]
    dependencies: list[str]
    estimated_complexity: str  # "low", "medium", "high"
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_markdown(self) -> str:
        """Generate markdown representation."""
        steps_md = ""
        for step in self.steps:
            steps_md += f"""
### Step {step.get('step_num', '?')}: {step.get('action', 'Action')}

**Target:** {step.get('target', 'N/A')}

{step.get('details', '')}

**Verification:** {step.get('verification', 'Manual review')}

"""

        files_md = "\n".join(
            f"- `{f.get('path', 'unknown')}` - {f.get('action', 'modify')}: {f.get('description', '')[:50]}"
            for f in self.file_changes
        )

        deps_md = "\n".join(f"- {d}" for d in self.dependencies) if self.dependencies else "*None*"

        return f"""# Patch Plan: {self.title}

**Debate ID:** {self.debate_id}
**Date:** {self.created_at[:10]}
**Complexity:** {self.estimated_complexity.upper()}

---

## Description

{self.description}

---

## Implementation Steps

{steps_md}

---

## File Changes

{files_md}

---

## Dependencies

{deps_md}

---

*Generated by aragora v0.8.0*
"""

    def to_dict(self) -> dict:
        return {
            "debate_id": self.debate_id,
            "title": self.title,
            "description": self.description,
            "steps": self.steps,
            "file_changes": self.file_changes,
            "dependencies": self.dependencies,
            "estimated_complexity": self.estimated_complexity,
            "created_at": self.created_at,
        }


class PRGenerator:
    """
    Generates PR artifacts from debate outcomes.

    Takes a DebateArtifact and produces structured documents
    suitable for creating pull requests.
    """

    def __init__(self, artifact: DebateArtifact):
        self.artifact = artifact

    def generate_decision_memo(self) -> DecisionMemo:
        """Generate a decision memo from the debate artifact."""
        consensus = self.artifact.consensus_proof

        # Extract key decisions from final answer
        final_answer = consensus.final_answer if consensus else ""
        key_decisions = self._extract_decisions(final_answer)

        # Extract evidence from provenance
        evidence = []
        if self.artifact.provenance_data:
            chain = self.artifact.provenance_data.get("chain", {})
            for record in chain.get("records", [])[:5]:
                evidence.append(
                    {
                        "source": record.get("source_type", "unknown"),
                        "summary": record.get("content", "")[:200],
                    }
                )

        # Build rationale from trace events
        rationale = self._build_rationale()

        # Extract dissenting views from consensus proof and high-severity critiques
        dissenting_views = self._extract_dissenting_views(consensus)

        # Extract open questions from unresolved critique issues
        open_questions = self._extract_open_questions(consensus)

        return DecisionMemo(
            debate_id=self.artifact.debate_id,
            title=self._extract_title(self.artifact.task),
            summary=final_answer[:500] + "..." if len(final_answer) > 500 else final_answer,
            key_decisions=key_decisions,
            rationale=rationale,
            supporting_evidence=evidence,
            dissenting_views=dissenting_views,
            open_questions=open_questions,
            consensus_confidence=consensus.confidence if consensus else 0,
            rounds_used=self.artifact.rounds,
            agent_count=len(self.artifact.agents),
        )

    def generate_patch_plan(self) -> PatchPlan:
        """Generate a patch plan from the debate artifact."""
        consensus = self.artifact.consensus_proof
        final_answer = consensus.final_answer if consensus else ""

        # Extract implementation steps
        steps = self._extract_steps(final_answer)

        # Infer file changes
        file_changes = self._infer_file_changes(final_answer)

        # Estimate complexity
        complexity = self._estimate_complexity()

        return PatchPlan(
            debate_id=self.artifact.debate_id,
            title=self._extract_title(self.artifact.task),
            description=self.artifact.task,
            steps=steps,
            file_changes=file_changes,
            dependencies=[],
            estimated_complexity=complexity,
        )

    def _extract_title(self, task: str) -> str:
        """Extract a short title from the task description."""
        # Take first sentence or first 60 chars
        if "." in task[:80]:
            return task[: task.index(".") + 1]
        return task[:60] + "..." if len(task) > 60 else task

    def _extract_decisions(self, text: str) -> list[str]:
        """Extract key decisions from debate conclusion."""
        decisions = []

        # Look for numbered items, bullet points, or decision keywords
        lines = text.split("\n")
        for line in lines:
            line = line.strip()
            # Check for numbered items
            if line and (line[0].isdigit() or line.startswith("-") or line.startswith("*")):
                # Clean up the line
                clean = line.lstrip("0123456789.-*) ").strip()
                if len(clean) > 10 and len(clean) < 200:
                    decisions.append(clean)

        # If no structured decisions found, split on sentences
        if not decisions and text:
            sentences = text.replace(".", ".\n").split("\n")
            decisions = [s.strip() for s in sentences[:5] if len(s.strip()) > 20]

        return decisions[:10]  # Limit to 10 decisions

    def _extract_steps(self, text: str) -> list[dict]:
        """Extract implementation steps from debate conclusion."""
        steps = []
        step_num = 1

        lines = text.split("\n")
        for line in lines:
            line = line.strip()
            # Look for step-like patterns
            if line and (line[0].isdigit() or line.lower().startswith("step")):
                clean = line.lstrip("0123456789.)-: ").strip()
                if len(clean) > 10:
                    steps.append(
                        {
                            "step_num": step_num,
                            "action": clean[:50],
                            "target": "TBD",
                            "details": clean,
                            "verification": "Manual review",
                        }
                    )
                    step_num += 1

        # If no steps found, create generic steps
        if not steps:
            steps = [
                {
                    "step_num": 1,
                    "action": "Review debate conclusions",
                    "target": "Documentation",
                    "details": "Review the full debate transcript for context",
                    "verification": "Team review",
                },
                {
                    "step_num": 2,
                    "action": "Implement core changes",
                    "target": "Source code",
                    "details": "Implement the agreed-upon solution",
                    "verification": "Unit tests pass",
                },
                {
                    "step_num": 3,
                    "action": "Update tests",
                    "target": "Test suite",
                    "details": "Add tests for new functionality",
                    "verification": "Coverage maintained",
                },
            ]

        return steps

    def _infer_file_changes(self, text: str) -> list[dict]:
        """Infer file changes from debate content."""
        changes = []

        # Look for file path patterns
        import re

        file_patterns = re.findall(r"`([a-zA-Z0-9_/\-\.]+\.[a-z]+)`", text)

        for path in file_patterns[:10]:
            changes.append(
                {
                    "path": path,
                    "action": "modify",
                    "description": "Changes discussed in debate",
                }
            )

        return changes

    def _build_rationale(self) -> str:
        """Build rationale from trace events."""
        if not self.artifact.trace_data:
            return "Rationale derived from multi-agent debate (decision stress-test) consensus."

        # Extract synthesis events
        events = self.artifact.trace_data.get("events", [])
        synthesis_events = [e for e in events if e.get("event_type") == "agent_synthesis"]

        if synthesis_events:
            last_synthesis = synthesis_events[-1]
            content = last_synthesis.get("content", {})
            return content.get("content", "")[:500]

        return "Consensus reached through structured multi-agent debate (decision stress-test)."

    def _extract_dissenting_views(self, consensus) -> list[str]:
        """Extract dissenting views from consensus proof and high-severity critiques."""
        dissenting = []

        # Get explicit dissenting views from consensus proof
        if consensus and hasattr(consensus, "dissenting_views"):
            dissenting.extend(consensus.dissenting_views)

        # Extract high-severity critique issues as potential dissent
        if consensus and hasattr(consensus, "critiques"):
            for critique in consensus.critiques:
                if critique.severity >= 0.7:  # High severity = significant disagreement
                    for issue in critique.issues[:2]:  # Top 2 issues per critique
                        dissent_text = f"[{critique.agent}] {issue}"
                        if dissent_text not in dissenting:
                            dissenting.append(dissent_text)

        return dissenting[:5]  # Limit to top 5 dissenting views

    def _extract_open_questions(self, consensus: Any) -> list[str]:
        """Extract open questions from unresolved or recurring critique issues."""
        questions: list[str] = []

        if not consensus or not hasattr(consensus, "critiques"):
            return questions

        # Track issue frequency across critiques
        issue_counts: dict[str, int] = {}
        for critique in consensus.critiques:
            for issue in critique.issues:
                # Normalize issue text for comparison
                key = issue[:100].lower().strip()
                issue_counts[key] = issue_counts.get(key, 0) + 1

        # Issues raised by multiple agents are likely unresolved questions
        for issue_key, count in issue_counts.items():
            if count >= 2:  # Raised by 2+ agents
                # Find the original full text
                for critique in consensus.critiques:
                    for issue in critique.issues:
                        if issue[:100].lower().strip() == issue_key:
                            questions.append(issue)
                            break
                    if len(questions) >= 3:
                        break
            if len(questions) >= 3:
                break

        return questions[:3]  # Limit to top 3 open questions

    def _estimate_complexity(self) -> str:
        """Estimate implementation complexity."""
        # Heuristics based on debate metrics
        rounds = self.artifact.rounds
        critiques = self.artifact.critique_count

        if rounds >= 4 or critiques >= 6:
            return "high"
        elif rounds >= 2 or critiques >= 3:
            return "medium"
        return "low"


def generate_pr_artifacts(artifact: DebateArtifact) -> dict:
    """Convenience function to generate all PR artifacts."""
    generator = PRGenerator(artifact)

    return {
        "decision_memo": generator.generate_decision_memo(),
        "patch_plan": generator.generate_patch_plan(),
    }
