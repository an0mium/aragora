"""
Type definitions for the hybrid implementation system.

These dataclasses represent the core data structures for:
- Implementation plans (generated by Gemini)
- Individual tasks with complexity routing
- Execution results
- Checkpoint/progress state
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Literal, Optional


@dataclass
class ImplementTask:
    """A single implementation task within a plan."""

    id: str
    description: str
    files: list[str]  # files to create/modify
    complexity: Literal["simple", "moderate", "complex"]
    dependencies: list[str] = field(default_factory=list)  # task IDs that must complete first

    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "description": self.description,
            "files": self.files,
            "complexity": self.complexity,
            "dependencies": self.dependencies,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ImplementTask":
        return cls(
            id=data["id"],
            description=data["description"],
            files=data.get("files", []),
            complexity=data.get("complexity", "moderate"),
            dependencies=data.get("dependencies", []),
        )


@dataclass
class ImplementPlan:
    """A complete implementation plan with multiple tasks."""

    design_hash: str
    tasks: list[ImplementTask]
    created_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        return {
            "design_hash": self.design_hash,
            "tasks": [t.to_dict() for t in self.tasks],
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ImplementPlan":
        return cls(
            design_hash=data["design_hash"],
            tasks=[ImplementTask.from_dict(t) for t in data.get("tasks", [])],
            created_at=datetime.fromisoformat(data["created_at"]),
        )


@dataclass
class TaskResult:
    """Result of executing a single task."""

    task_id: str
    success: bool
    diff: str = ""
    error: Optional[str] = None
    model_used: Optional[str] = None
    duration_seconds: float = 0.0

    def to_dict(self) -> dict:
        return {
            "task_id": self.task_id,
            "success": self.success,
            "diff": self.diff,
            "error": self.error,
            "model_used": self.model_used,
            "duration_seconds": self.duration_seconds,
        }


@dataclass
class ImplementProgress:
    """Checkpoint state for crash recovery."""

    plan: ImplementPlan
    completed_tasks: list[str] = field(default_factory=list)
    current_task: Optional[str] = None
    git_stash_ref: Optional[str] = None
    results: list[TaskResult] = field(default_factory=list)

    def to_dict(self) -> dict:
        return {
            "plan": self.plan.to_dict(),
            "completed_tasks": self.completed_tasks,
            "current_task": self.current_task,
            "git_stash_ref": self.git_stash_ref,
            "results": [r.to_dict() for r in self.results],
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ImplementProgress":
        return cls(
            plan=ImplementPlan.from_dict(data["plan"]),
            completed_tasks=data.get("completed_tasks", []),
            current_task=data.get("current_task"),
            git_stash_ref=data.get("git_stash_ref"),
            results=[
                TaskResult(
                    task_id=r["task_id"],
                    success=r["success"],
                    diff=r.get("diff", ""),
                    error=r.get("error"),
                    model_used=r.get("model_used"),
                    duration_seconds=r.get("duration_seconds", 0.0),
                )
                for r in data.get("results", [])
            ],
        )
