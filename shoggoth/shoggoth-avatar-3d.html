<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shoggoth Oracle — 3D Avatar v4</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0e17;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100vh;
    cursor: crosshair;
  }
  canvas { display: block; }
  #info {
    position: fixed;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Georgia', serif;
    font-size: 13px;
    color: rgba(127, 219, 202, 0.4);
    letter-spacing: 0.1em;
    pointer-events: none;
  }
  .vignette {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    background: radial-gradient(ellipse at center, transparent 50%, rgba(10,14,23,0.7) 100%);
    z-index: 1;
  }
</style>
</head>
<body>
<div class="vignette"></div>
<div id="info">move your cursor to disturb the Oracle</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// =============================================
// SHOGGOTH ORACLE — 3D Avatar v4
// Fixed: face always front-facing, dynamic palantir,
// thicker tentacles, better eye visibility
// =============================================

// === SCENE ===
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0e17, 0.06);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0.2, 5.0);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;
document.body.appendChild(renderer.domElement);

// === MOUSE ===
const mouse = new THREE.Vector2(0, 0);
const targetMouse = new THREE.Vector2(0, 0);
document.addEventListener('mousemove', (e) => {
  targetMouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  targetMouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
});
document.addEventListener('touchmove', (e) => {
  const touch = e.touches[0];
  targetMouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
  targetMouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
}, { passive: true });

// === NOISE ===
function noise3D(x,y,z){return Math.sin(x*1.27+y*3.43+z*2.17)*Math.sin(y*2.64+z*1.87+x*3.91)*Math.sin(z*1.53+x*2.79+y*1.34);}
function fbm(x,y,z,o){let v=0,a=0.5,f=1;for(let i=0;i<o;i++){v+=a*noise3D(x*f,y*f,z*f);a*=0.5;f*=2.1;}return v;}

// === LIGHTING ===
scene.add(new THREE.AmbientLight(0x1a2a3a, 0.5));

const palantirLight = new THREE.PointLight(0x7fdbca, 2.5, 8);
palantirLight.position.set(0, -1.2, 1.8);
scene.add(palantirLight);

const goldLight = new THREE.PointLight(0xd4a853, 0.9, 6);
goldLight.position.set(2, 1, 2);
scene.add(goldLight);

const greenLight = new THREE.PointLight(0x1a472a, 1.2, 8);
greenLight.position.set(-2, 2, -3);
scene.add(greenLight);

const redLight = new THREE.PointLight(0x8b2d2d, 0.4, 5);
redLight.position.set(-1.5, -0.5, 1);
scene.add(redLight);

// Strong front light for the face
const faceLight = new THREE.PointLight(0xeeddcc, 1.2, 6);
faceLight.position.set(0, 0.8, 3.5);
scene.add(faceLight);

// ==========================================
// PAINT CASSANDRA FACE ON CANVAS
// ==========================================
function paintCassandraFace(size) {
  const c = document.createElement('canvas');
  c.width = size; c.height = size;
  const ctx = c.getContext('2d');
  const cx = size/2, cy = size/2;
  const s = size/512; // scale factor

  // Clear transparent
  ctx.clearRect(0,0,size,size);

  // --- FACE OVAL ---
  ctx.save();
  ctx.beginPath();
  ctx.ellipse(cx, cy + 10*s, 170*s, 220*s, 0, 0, Math.PI*2);
  // Marble gradient
  const faceGrad = ctx.createRadialGradient(cx-30*s, cy-60*s, 20*s, cx, cy, 200*s);
  faceGrad.addColorStop(0, '#f0e6d6');
  faceGrad.addColorStop(0.4, '#e8dcc8');
  faceGrad.addColorStop(0.7, '#d8ccb8');
  faceGrad.addColorStop(1, '#c0b098');
  ctx.fillStyle = faceGrad;
  ctx.fill();

  // Subtle marble veining
  ctx.globalAlpha = 0.04;
  for(let i=0;i<8;i++){
    ctx.beginPath();
    ctx.moveTo(cx + (Math.random()-0.5)*200*s, cy-180*s);
    ctx.bezierCurveTo(
      cx+(Math.random()-0.5)*300*s, cy-60*s,
      cx+(Math.random()-0.5)*300*s, cy+60*s,
      cx+(Math.random()-0.5)*200*s, cy+180*s
    );
    ctx.strokeStyle = '#b0a090';
    ctx.lineWidth = (1+Math.random()*2)*s;
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // --- CHEEKBONE HIGHLIGHTS ---
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.beginPath();
  ctx.ellipse(cx-80*s, cy+10*s, 50*s, 25*s, -0.3, 0, Math.PI*2);
  ctx.fillStyle = '#fff8f0';
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx+80*s, cy+10*s, 50*s, 25*s, 0.3, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  // --- BROW RIDGE SHADOW ---
  ctx.save();
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.ellipse(cx, cy-70*s, 130*s, 18*s, 0, 0, Math.PI*2);
  ctx.fillStyle = '#8a7a6a';
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  // --- EYEBROWS ---
  function drawBrow(xOff, flip) {
    ctx.save();
    ctx.translate(cx + xOff*s, cy - 95*s);
    if(flip) ctx.scale(-1,1);
    ctx.beginPath();
    ctx.moveTo(-55*s, 8*s);
    ctx.bezierCurveTo(-40*s, -8*s, -5*s, -14*s, 40*s, 0);
    ctx.bezierCurveTo(-5*s, -6*s, -40*s, 0, -55*s, 8*s);
    ctx.fillStyle = '#6a5a4a';
    ctx.fill();
    ctx.restore();
  }
  drawBrow(-60, false);
  drawBrow(60, true);

  // --- EYE SOCKETS (shadow) ---
  function drawEyeSocket(xOff) {
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.beginPath();
    ctx.ellipse(cx+xOff*s, cy-55*s, 48*s, 28*s, 0, 0, Math.PI*2);
    ctx.fillStyle = '#5a4a3a';
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  drawEyeSocket(-62);
  drawEyeSocket(62);

  // --- EYES ---
  function drawEye(xOff) {
    const ex = cx + xOff*s;
    const ey = cy - 55*s;

    // Almond shape clip
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ex-40*s, ey);
    ctx.bezierCurveTo(ex-25*s, ey-22*s, ex+25*s, ey-22*s, ex+40*s, ey);
    ctx.bezierCurveTo(ex+25*s, ey+18*s, ex-25*s, ey+18*s, ex-40*s, ey);
    ctx.closePath();
    ctx.clip();

    // Sclera
    ctx.fillStyle = '#0d1520';
    ctx.fillRect(ex-45*s, ey-25*s, 90*s, 50*s);

    // Iris — teal glow
    const irisGrad = ctx.createRadialGradient(ex, ey, 2*s, ex, ey, 22*s);
    irisGrad.addColorStop(0, '#aaf0e4');
    irisGrad.addColorStop(0.3, '#7fdbca');
    irisGrad.addColorStop(0.7, '#4aaa98');
    irisGrad.addColorStop(1, '#2a7a6a');
    ctx.beginPath();
    ctx.arc(ex, ey, 22*s, 0, Math.PI*2);
    ctx.fillStyle = irisGrad;
    ctx.fill();

    // Iris glow
    ctx.globalAlpha = 0.3;
    ctx.beginPath();
    ctx.arc(ex, ey, 28*s, 0, Math.PI*2);
    ctx.fillStyle = '#7fdbca';
    ctx.fill();
    ctx.globalAlpha = 1;

    // Pupil
    ctx.beginPath();
    ctx.arc(ex, ey, 8*s, 0, Math.PI*2);
    ctx.fillStyle = '#050a10';
    ctx.fill();

    // Pupil light reflection
    ctx.beginPath();
    ctx.arc(ex+5*s, ey-5*s, 3*s, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.fill();

    ctx.restore();

    // Eye outline
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ex-40*s, ey);
    ctx.bezierCurveTo(ex-25*s, ey-22*s, ex+25*s, ey-22*s, ex+40*s, ey);
    ctx.bezierCurveTo(ex+25*s, ey+18*s, ex-25*s, ey+18*s, ex-40*s, ey);
    ctx.closePath();
    ctx.strokeStyle = '#4a3a2a';
    ctx.lineWidth = 1.5*s;
    ctx.stroke();
    ctx.restore();

    // Upper lash line (thicker)
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(ex-40*s, ey);
    ctx.bezierCurveTo(ex-25*s, ey-23*s, ex+25*s, ey-23*s, ex+40*s, ey);
    ctx.strokeStyle = '#3a2a1a';
    ctx.lineWidth = 2.5*s;
    ctx.stroke();
    ctx.restore();
  }
  drawEye(-62);
  drawEye(62);

  // --- NOSE ---
  // Bridge shadow
  ctx.save();
  ctx.globalAlpha = 0.1;
  ctx.beginPath();
  ctx.moveTo(cx-8*s, cy-40*s);
  ctx.lineTo(cx-12*s, cy+20*s);
  ctx.lineTo(cx+12*s, cy+20*s);
  ctx.lineTo(cx+8*s, cy-40*s);
  ctx.fillStyle = '#7a6a5a';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Nose highlight
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.moveTo(cx, cy-35*s);
  ctx.lineTo(cx-2*s, cy+15*s);
  ctx.lineTo(cx+2*s, cy+15*s);
  ctx.fillStyle = '#fff8f0';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Nose tip
  ctx.beginPath();
  ctx.ellipse(cx, cy+20*s, 14*s, 8*s, 0, 0, Math.PI*2);
  const noseTipGrad = ctx.createRadialGradient(cx, cy+18*s, 2*s, cx, cy+20*s, 14*s);
  noseTipGrad.addColorStop(0, '#e8dcc8');
  noseTipGrad.addColorStop(1, '#c8b8a8');
  ctx.fillStyle = noseTipGrad;
  ctx.fill();

  // Nostrils
  ctx.globalAlpha = 0.2;
  ctx.beginPath();
  ctx.ellipse(cx-10*s, cy+24*s, 6*s, 4*s, -0.3, 0, Math.PI*2);
  ctx.fillStyle = '#5a4a3a';
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(cx+10*s, cy+24*s, 6*s, 4*s, 0.3, 0, Math.PI*2);
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  // --- LIPS ---
  // Upper lip
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(cx-42*s, cy+62*s);
  ctx.bezierCurveTo(cx-25*s, cy+55*s, cx-8*s, cy+52*s, cx, cy+56*s); // cupid's bow left
  ctx.bezierCurveTo(cx+8*s, cy+52*s, cx+25*s, cy+55*s, cx+42*s, cy+62*s); // cupid's bow right
  ctx.bezierCurveTo(cx+20*s, cy+66*s, cx-20*s, cy+66*s, cx-42*s, cy+62*s);
  const upperLipGrad = ctx.createLinearGradient(cx, cy+52*s, cx, cy+66*s);
  upperLipGrad.addColorStop(0, '#c49a88');
  upperLipGrad.addColorStop(1, '#b08878');
  ctx.fillStyle = upperLipGrad;
  ctx.fill();
  ctx.restore();

  // Lower lip (fuller)
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(cx-38*s, cy+64*s);
  ctx.bezierCurveTo(cx-20*s, cy+64*s, cx-10*s, cy+64*s, cx, cy+64*s);
  ctx.bezierCurveTo(cx+10*s, cy+64*s, cx+20*s, cy+64*s, cx+38*s, cy+64*s);
  ctx.bezierCurveTo(cx+25*s, cy+82*s, cx-25*s, cy+82*s, cx-38*s, cy+64*s);
  const lowerLipGrad = ctx.createLinearGradient(cx, cy+64*s, cx, cy+82*s);
  lowerLipGrad.addColorStop(0, '#c09888');
  lowerLipGrad.addColorStop(0.6, '#b88878');
  lowerLipGrad.addColorStop(1, '#a07868');
  ctx.fillStyle = lowerLipGrad;
  ctx.fill();

  // Lip shine
  ctx.globalAlpha = 0.15;
  ctx.beginPath();
  ctx.ellipse(cx, cy+72*s, 18*s, 6*s, 0, 0, Math.PI*2);
  ctx.fillStyle = '#ffffff';
  ctx.fill();
  ctx.globalAlpha = 1;
  ctx.restore();

  // Mouth line
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(cx-36*s, cy+63*s);
  ctx.bezierCurveTo(cx-15*s, cy+65*s, cx+15*s, cy+65*s, cx+36*s, cy+63*s);
  ctx.strokeStyle = '#6a4a3a';
  ctx.lineWidth = 1.5*s;
  ctx.stroke();
  ctx.restore();

  // --- GOLD TEAR TRACKS (Cassandra weeps) ---
  function drawTear(xOff) {
    ctx.save();
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.moveTo(cx+xOff*s, cy-35*s);
    ctx.bezierCurveTo(
      cx+xOff*s-3*s, cy,
      cx+xOff*s+2*s, cy+40*s,
      cx+xOff*s-1*s, cy+90*s
    );
    ctx.strokeStyle = '#d4a853';
    ctx.lineWidth = 3*s;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Gleam
    ctx.globalAlpha = 0.1;
    ctx.lineWidth = 6*s;
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();
  }
  drawTear(-58);
  drawTear(58);

  // --- LAUREL CROWN HINTS ---
  ctx.save();
  ctx.globalAlpha = 0.2;
  function drawLeaf(x, y, angle, sz) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.ellipse(0, 0, sz*0.4, sz, 0, 0, Math.PI*2);
    ctx.fillStyle = '#4a7a3a';
    ctx.fill();
    ctx.restore();
  }
  // Crown arc
  for(let i=0; i<8; i++) {
    const a = -0.8 + (i/7)*1.6;
    const lx = cx + Math.sin(a)*130*s;
    const ly = cy - 180*s + Math.cos(a)*40*s;
    drawLeaf(lx, ly, a+Math.PI/2, 12*s);
  }
  ctx.globalAlpha = 1;
  ctx.restore();

  // --- FACE EDGE FADE (smooth into transparency) ---
  ctx.save();
  ctx.globalCompositeOperation = 'destination-in';
  const fadeMask = ctx.createRadialGradient(cx, cy+10*s, 100*s, cx, cy+10*s, 220*s);
  fadeMask.addColorStop(0, 'rgba(255,255,255,1)');
  fadeMask.addColorStop(0.7, 'rgba(255,255,255,1)');
  fadeMask.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = fadeMask;
  ctx.fillRect(0,0,size,size);
  ctx.restore();

  return c;
}

// Create texture
const faceCanvas = paintCassandraFace(512);
const faceTexture = new THREE.CanvasTexture(faceCanvas);
faceTexture.needsUpdate = true;

// ==========================================
// SHOGGOTH BODY
// ==========================================
const bodyGeo = new THREE.SphereGeometry(1.3, 96, 96);
const bodyMat = new THREE.MeshStandardMaterial({
  color: 0x1a3a2a, roughness: 0.65, metalness: 0.3, transparent: true, opacity: 0.93,
});
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.set(0, 0.2, 0);
scene.add(body);
const bodyOrigPos = Float32Array.from(bodyGeo.attributes.position.array);

// ==========================================
// CASSANDRA FACE — Canvas texture on curved plane
// ==========================================
// Use a section of a sphere so the face wraps slightly
const faceGeo = new THREE.SphereGeometry(1.35, 48, 48,
  Math.PI/2 - 0.55, 1.1,  // horizontal arc
  Math.PI/2 - 0.65, 1.3   // vertical arc
);
const faceMat = new THREE.MeshStandardMaterial({
  map: faceTexture,
  transparent: true,
  alphaTest: 0.01,
  roughness: 0.8,
  metalness: 0.05,
  side: THREE.FrontSide,
  depthWrite: true,
});
const faceMesh = new THREE.Mesh(faceGeo, faceMat);
faceMesh.position.set(0, 0.2, 0.08); // Slightly in front of body center
scene.add(faceMesh);

// ==========================================
// TAPERED TENTACLES — Biased to lower third
// ==========================================
const tentacles = [];
const tentacleEyes = [];
const tentacleCount = 14;

function buildTaperedTube(curve, tubSegs, radSegs, baseR, tipR) {
  const frames = curve.computeFrenetFrames(tubSegs, false);
  const verts=[], inds=[], norms=[], uvs=[];
  for(let i=0;i<=tubSegs;i++){
    const t=i/tubSegs;
    // Smooth taper: cubic falloff looks more organic than linear
    const taper = 1 - t*t;
    const r = tipR + (baseR-tipR)*taper;
    const P=curve.getPointAt(t);
    const N=frames.normals[i], B=frames.binormals[i];
    for(let j=0;j<=radSegs;j++){
      const v=(j/radSegs)*Math.PI*2;
      const sn=Math.sin(v), cs=-Math.cos(v);
      const nx=cs*N.x+sn*B.x, ny=cs*N.y+sn*B.y, nz=cs*N.z+sn*B.z;
      norms.push(nx,ny,nz);
      verts.push(P.x+r*nx, P.y+r*ny, P.z+r*nz);
      uvs.push(t, j/radSegs);
    }
  }
  for(let i=0;i<tubSegs;i++){
    for(let j=0;j<radSegs;j++){
      const a=i*(radSegs+1)+j, b=(i+1)*(radSegs+1)+j;
      const c=b+1, d=a+1;
      inds.push(a,b,d,b,c,d);
    }
  }
  const g=new THREE.BufferGeometry();
  g.setIndex(inds);
  g.setAttribute('position',new THREE.Float32BufferAttribute(verts,3));
  g.setAttribute('normal',new THREE.Float32BufferAttribute(norms,3));
  g.setAttribute('uv',new THREE.Float32BufferAttribute(uvs,2));
  return g;
}

function createTentacle(baseAngle, length, yStart, baseThick) {
  const segs = 24;
  const pts = [];
  for(let i=0;i<=segs;i++){
    const t=i/segs;
    const a = baseAngle + Math.sin(t*Math.PI)*0.6;
    const r = 1.3+t*length;
    const x=Math.cos(a)*r*(0.7+t*0.5);
    // Tentacles droop downward
    const y=yStart - t*1.2 + Math.sin(t*Math.PI*0.5)*0.2;
    const z=Math.sin(a)*r*(0.7+t*0.5);
    pts.push(new THREE.Vector3(x,y,z));
  }
  const curve = new THREE.CatmullRomCurve3(pts);
  const tipR = baseThick*0.06;
  const geo = buildTaperedTube(curve, 32, 8, baseThick, tipR);
  const mat = new THREE.MeshStandardMaterial({
    color: 0x1a4a2f, roughness: 0.5, metalness: 0.25, transparent: true, opacity: 0.9,
  });
  return {
    mesh: new THREE.Mesh(geo, mat), curve, baseAngle, length, yStart, baseThick,
    segs, phase: Math.random()*Math.PI*2, speed: 0.2+Math.random()*0.35,
    amplitude: 0.2+Math.random()*0.35,
  };
}

// LOWER-BIASED tentacle placement
for(let i=0;i<tentacleCount;i++){
  // Angles spread full circle but yStart biased downward
  const angle = (i/tentacleCount)*Math.PI*2;
  const length = 1.0+Math.random()*1.5;

  // Most tentacles start from lower hemisphere
  let yOff;
  if(i < tentacleCount*0.7) {
    // 70% from bottom third
    yOff = -0.5 - Math.random()*0.6;
  } else {
    // 30% from middle
    yOff = -0.1 - Math.random()*0.4;
  }

  const thick = 0.14+Math.random()*0.12; // 2x thicker bases (was 0.07-0.13)
  const t = createTentacle(angle, length, yOff, thick);
  t.mesh.position.set(0, 0.2, 0);
  scene.add(t.mesh);
  tentacles.push(t);
}

// === TENTACLE EYES (fixed rendering) ===
const tentEyeGeo = new THREE.SphereGeometry(0.055, 12, 12); // larger for thicker tentacles
tentacles.forEach((tent,tIdx) => {
  [0.15, 0.35, 0.55, 0.75].forEach(tPos => {
    if(Math.random()>0.55) return;

    // Sclera (white sphere - always the base)
    const scleraMat = new THREE.MeshBasicMaterial({
      color: 0xd0e8e0, transparent: true, opacity: 0,
    });
    const sclera = new THREE.Mesh(tentEyeGeo, scleraMat);

    // Iris (teal, slightly smaller, on front)
    const irisGeo = new THREE.SphereGeometry(0.025, 10, 10);
    const irisMat = new THREE.MeshBasicMaterial({
      color: 0x7fdbca, transparent: true, opacity: 1,
    });
    const iris = new THREE.Mesh(irisGeo, irisMat);
    iris.position.set(0, 0, 0.018);
    sclera.add(iris);

    // Pupil (dark, small, on very front)
    const pupilGeo = new THREE.SphereGeometry(0.012, 8, 8);
    const pupilMat = new THREE.MeshBasicMaterial({ color: 0x050a10 });
    const pupil = new THREE.Mesh(pupilGeo, pupilMat);
    pupil.position.set(0, 0, 0.028);
    sclera.add(pupil);

    scene.add(sclera);
    tentacleEyes.push({
      mesh: sclera, tentacleIdx: tIdx, tPos,
      blinkPhase: Math.random()*Math.PI*2, blinkSpeed: 0.1+Math.random()*0.12,
    });
  });
});

// === BODY EYES (on surface, fixed rendering) ===
const bodyEyes = [];
for(let i=0;i<18;i++){
  const theta=Math.random()*Math.PI*2;
  const phi=Math.acos(2*Math.random()-1);
  const r=1.32;
  const x=r*Math.sin(phi)*Math.cos(theta);
  const y=r*Math.sin(phi)*Math.sin(theta)+0.2;
  const z=r*Math.cos(phi);
  // Keep eyes on front hemisphere and not on face area
  if(z<0.3) continue;
  // Avoid face zone (center-upper front)
  if(Math.abs(x)<0.4 && y>-0.2 && y<0.8 && z>0.8) continue;

  const scleraMat = new THREE.MeshBasicMaterial({color:0xd0e8e0, transparent:true, opacity:0});
  const eyeMesh = new THREE.Mesh(new THREE.SphereGeometry(0.05,12,12), scleraMat);
  eyeMesh.position.set(x,y,z);

  const iris = new THREE.Mesh(
    new THREE.SphereGeometry(0.032,10,10),
    new THREE.MeshBasicMaterial({color:0x7fdbca})
  );
  iris.position.set(0,0,0.025);
  eyeMesh.add(iris);

  const pupil = new THREE.Mesh(
    new THREE.SphereGeometry(0.015,8,8),
    new THREE.MeshBasicMaterial({color:0x050a10})
  );
  pupil.position.set(0,0,0.038);
  eyeMesh.add(pupil);

  scene.add(eyeMesh);
  bodyEyes.push({
    mesh:eyeMesh, basePos:new THREE.Vector3(x,y,z),
    blinkPhase:Math.random()*Math.PI*2, blinkSpeed:0.12+Math.random()*0.18,
  });
}

// ==========================================
// PALANTÍR
// ==========================================
const palantir = new THREE.Mesh(
  new THREE.SphereGeometry(0.38, 64, 64),
  new THREE.MeshStandardMaterial({
    color:0x3a8a7a, roughness:0.05, metalness:0.3,
    transparent:true, opacity:0.55, emissive:0x1a4a3a, emissiveIntensity:0.3,
  })
);
palantir.position.set(0, -0.9, 2.0);
scene.add(palantir);

const core = new THREE.Mesh(
  new THREE.SphereGeometry(0.18,32,32),
  new THREE.MeshBasicMaterial({color:0x7fdbca,transparent:true,opacity:0.6})
);
core.position.copy(palantir.position);
scene.add(core);

// Dynamic flicker lights inside palantír
const blueFlicker = new THREE.PointLight(0x3366ff, 0, 3);
blueFlicker.position.copy(palantir.position);
blueFlicker.position.x += 0.15;
scene.add(blueFlicker);

const redFlicker = new THREE.PointLight(0xff3333, 0, 3);
redFlicker.position.copy(palantir.position);
redFlicker.position.x -= 0.15;
scene.add(redFlicker);

const whiteGlint = new THREE.PointLight(0xffffff, 0, 2);
whiteGlint.position.copy(palantir.position);
whiteGlint.position.z += 0.2;
scene.add(whiteGlint);

// Glow
const gc=document.createElement('canvas'); gc.width=128; gc.height=128;
const gx=gc.getContext('2d');
const gg=gx.createRadialGradient(64,64,0,64,64,64);
gg.addColorStop(0,'rgba(127,219,202,0.6)');
gg.addColorStop(0.4,'rgba(127,219,202,0.15)');
gg.addColorStop(1,'rgba(127,219,202,0)');
gx.fillStyle=gg;gx.fillRect(0,0,128,128);
const gsMat=new THREE.SpriteMaterial({map:new THREE.CanvasTexture(gc),transparent:true,blending:THREE.AdditiveBlending});
const gs=new THREE.Sprite(gsMat);
gs.position.copy(palantir.position);
gs.scale.set(3,3,1);
scene.add(gs);

// ==========================================
// PARTICLES
// ==========================================
const partCount=80;
const pg=new THREE.BufferGeometry();
const pp=new Float32Array(partCount*3);
const ps=[];
for(let i=0;i<partCount;i++){
  pp[i*3]=(Math.random()-0.5)*8;pp[i*3+1]=(Math.random()-0.5)*6;pp[i*3+2]=(Math.random()-0.5)*6;
  ps.push({vx:(Math.random()-0.5)*0.003,vy:(Math.random()-0.5)*0.003+0.002,vz:(Math.random()-0.5)*0.003});
}
pg.setAttribute('position',new THREE.BufferAttribute(pp,3));
const parts=new THREE.Points(pg,new THREE.PointsMaterial({color:0x7fdbca,size:0.03,transparent:true,opacity:0.4,blending:THREE.AdditiveBlending}));
scene.add(parts);

// ==========================================
// ANIMATION
// ==========================================
const clock=new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();

  mouse.x+=(targetMouse.x-mouse.x)*0.05;
  mouse.y+=(targetMouse.y-mouse.y)*0.05;

  // --- BODY ---
  const bpos=bodyGeo.attributes.position.array;
  for(let i=0;i<bpos.length;i+=3){
    const ox=bodyOrigPos[i],oy=bodyOrigPos[i+1],oz=bodyOrigPos[i+2];
    const n=fbm(ox*1.5+t*0.3,oy*1.5+t*0.25,oz*1.5+t*0.2,3);
    const m=(mouse.x*ox+mouse.y*oy)*0.12;
    const d=1.0+n*0.2+m;
    bpos[i]=ox*d;bpos[i+1]=oy*d;bpos[i+2]=oz*d;
  }
  bodyGeo.attributes.position.needsUpdate=true;
  bodyGeo.computeVertexNormals();

  body.rotation.y=t*0.06+mouse.x*0.25;
  body.rotation.x=Math.sin(t*0.12)*0.04+mouse.y*0.1;

  // Face always faces forward — only subtle mouse response, no time drift
  faceMesh.rotation.y = mouse.x * 0.15;
  faceMesh.rotation.x = mouse.y * 0.08;

  // --- TENTACLES ---
  tentacles.forEach(tent=>{
    const {mesh,baseAngle,length,yStart,baseThick,segs,phase,speed,amplitude}=tent;
    const pts=[];
    for(let i=0;i<=segs;i++){
      const s=i/segs;
      const wave=Math.sin(t*speed+phase+s*Math.PI*2)*amplitude*s;
      const mw=(mouse.x*Math.cos(baseAngle)+mouse.y*Math.sin(baseAngle))*0.3*s;
      const a=baseAngle+wave+mw;
      const r=1.3+s*length;
      pts.push(new THREE.Vector3(
        Math.cos(a)*r*(0.7+s*0.5),
        yStart-s*1.2+Math.sin(s*Math.PI*0.5+t*speed*0.5)*0.2+wave*0.25,
        Math.sin(a)*r*(0.7+s*0.5)
      ));
    }
    const curve=new THREE.CatmullRomCurve3(pts);
    tent.curve=curve;
    const pulse=1+Math.sin(t+phase)*0.06;
    const ng=buildTaperedTube(curve,32,8,baseThick*pulse,baseThick*0.06);
    mesh.geometry.dispose();
    mesh.geometry=ng;
  });

  // --- TENTACLE EYES ---
  tentacleEyes.forEach(te=>{
    const tent=tentacles[te.tentacleIdx];
    if(!tent.curve)return;
    const pt=tent.curve.getPointAt(Math.min(te.tPos,0.99));
    const tan=tent.curve.getTangentAt(Math.min(te.tPos,0.99));
    const up=new THREE.Vector3(0,1,0);
    const side=new THREE.Vector3().crossVectors(tan,up).normalize();
    const localR=tent.baseThick*(1-te.tPos*te.tPos)+tent.baseThick*0.06;

    te.mesh.position.set(
      pt.x+side.x*localR*1.2,
      pt.y+side.y*localR*1.2+0.2,
      pt.z+side.z*localR*1.2
    );

    // Look outward + toward mouse
    te.mesh.lookAt(
      te.mesh.position.x+side.x*2+mouse.x,
      te.mesh.position.y+mouse.y*0.5,
      te.mesh.position.z+side.z*2+1
    );

    // Blink: sclera opacity controls visibility
    const bc=Math.sin(t*te.blinkSpeed+te.blinkPhase);
    const open=bc>0.75?(bc-0.75)/0.25:0;
    te.mesh.material.opacity=open*0.95;
    // Children (iris, pupil) are always opaque=1, they appear when sclera appears
  });

  // --- BODY EYES ---
  bodyEyes.forEach(eye=>{
    const bc=Math.sin(t*eye.blinkSpeed+eye.blinkPhase);
    const open=bc>0.8?(bc-0.8)/0.2:0;
    eye.mesh.material.opacity=open*0.95;
    eye.mesh.lookAt(eye.basePos.x+mouse.x*2,eye.basePos.y+mouse.y*2,eye.basePos.z+3);
  });

  // --- FACE subtle breathing ---
  faceMesh.position.z = 0.08 + Math.sin(t*0.4)*0.01;

  // --- PALANTÍR (dynamic with blue/red glints) ---
  const pBase = 0.5 + Math.sin(t*1.5)*0.2;
  // Core throb with irregular flicker
  const flick = Math.sin(t*7.3)*Math.sin(t*11.1)*Math.sin(t*5.7);
  core.material.opacity = pBase + flick*0.15;

  // Color-shift the core between teal, blue, and warm orange
  const colorPhase = t * 0.4;
  const cR = 0.5 + Math.sin(colorPhase)*0.15 + Math.sin(colorPhase*3.7)*0.08;
  const cG = 0.86 + Math.sin(colorPhase*1.3)*0.1;
  const cB = 0.79 + Math.cos(colorPhase*0.9)*0.15;
  core.material.color.setRGB(cR, cG, cB);

  // Glow sprite pulses with slight irregularity
  gs.scale.setScalar(2.2 + Math.sin(t*1.5)*0.6 + flick*0.3);
  gsMat.opacity = 0.3 + Math.sin(t*1.5)*0.15 + Math.abs(flick)*0.1;

  // Main palantír light throbs
  palantirLight.intensity = 2.0 + Math.sin(t*1.5)*0.8 + flick*0.5;

  // Blue flicker — sharp bursts at irregular intervals
  const blueBurst = Math.max(0, Math.sin(t*4.3)*Math.sin(t*9.7) - 0.6) * 5.0;
  blueFlicker.intensity = blueBurst;
  blueFlicker.position.x = palantir.position.x + Math.sin(t*3.1)*0.15;
  blueFlicker.position.y = palantir.position.y + Math.cos(t*2.7)*0.1;

  // Red flicker — slower, deeper pulses
  const redBurst = Math.max(0, Math.sin(t*2.1)*Math.sin(t*6.3) - 0.5) * 3.0;
  redFlicker.intensity = redBurst;
  redFlicker.position.x = palantir.position.x + Math.cos(t*2.3)*0.15;
  redFlicker.position.y = palantir.position.y + Math.sin(t*3.9)*0.1;

  // White glint — rare, bright sparks
  const spark = Math.max(0, Math.sin(t*13.7)*Math.sin(t*17.3) - 0.85) * 12.0;
  whiteGlint.intensity = spark;

  // Palantír glass itself slowly rotates + wobbles
  palantir.rotation.y = t*0.2;
  palantir.rotation.x = Math.sin(t*0.3)*0.05;

  // --- PARTICLES ---
  const pa=parts.geometry.attributes.position.array;
  for(let i=0;i<partCount;i++){
    pa[i*3]+=ps[i].vx;pa[i*3+1]+=ps[i].vy;pa[i*3+2]+=ps[i].vz;
    if(Math.abs(pa[i*3+1])>3){pa[i*3]=(Math.random()-0.5)*6;pa[i*3+1]=-3;pa[i*3+2]=(Math.random()-0.5)*4;}
  }
  parts.geometry.attributes.position.needsUpdate=true;

  // --- CAMERA ---
  camera.position.x=mouse.x*0.5;
  camera.position.y=0.2+mouse.y*0.3;
  camera.lookAt(0,0.1,0);

  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
