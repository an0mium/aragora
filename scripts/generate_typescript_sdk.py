#!/usr/bin/env python3
"""
Generate TypeScript SDK types from OpenAPI specification.

Uses datamodel-code-generator to convert the OpenAPI schema into TypeScript
type definitions that can be used by the TypeScript SDK.

Usage:
    python scripts/generate_typescript_sdk.py
    python scripts/generate_typescript_sdk.py --openapi docs/api/openapi.json
    python scripts/generate_typescript_sdk.py --output sdk/typescript/src/generated-types.ts
"""

import argparse
import json
import subprocess
import sys
from pathlib import Path

# Default paths
DEFAULT_OPENAPI_PATH = Path("docs/api/openapi.json")
DEFAULT_OUTPUT_PATH = Path("sdk/typescript/src/generated-types.ts")


def check_dependencies() -> bool:
    """Check if required tools are installed."""
    try:
        result = subprocess.run(
            ["datamodel-codegen", "--version"],
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            print("Error: datamodel-codegen not found.", file=sys.stderr)
            print("Install with: pip install datamodel-code-generator", file=sys.stderr)
            return False
        return True
    except FileNotFoundError:
        print("Error: datamodel-codegen not found.", file=sys.stderr)
        print("Install with: pip install datamodel-code-generator", file=sys.stderr)
        return False


def generate_typescript_types(
    openapi_path: Path,
    output_path: Path,
    *,
    strict_optional: bool = True,
    use_union_operator: bool = True,
) -> bool:
    """
    Generate TypeScript types from OpenAPI spec.

    Args:
        openapi_path: Path to OpenAPI JSON/YAML file
        output_path: Output path for generated TypeScript file
        strict_optional: Use strict optional types
        use_union_operator: Use | instead of Union

    Returns:
        True if generation succeeded
    """
    if not openapi_path.exists():
        print(f"Error: OpenAPI spec not found at {openapi_path}", file=sys.stderr)
        print("Run 'python scripts/generate_openapi.py' first.", file=sys.stderr)
        return False

    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Build command
    cmd = [
        "datamodel-codegen",
        "--input",
        str(openapi_path),
        "--output",
        str(output_path),
        "--input-file-type",
        "openapi",
        "--output-model-type",
        "dataclasses.dataclass",  # Simplest output
        "--target-python-version",
        "3.11",
        "--use-annotated",
    ]

    if strict_optional:
        cmd.append("--strict-nullable")

    if use_union_operator:
        cmd.append("--use-union-operator")

    print(f"Generating TypeScript types from {openapi_path}...")
    print(f"Output: {output_path}")

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"Error generating types: {result.stderr}", file=sys.stderr)
            return False

        if result.stdout:
            print(result.stdout)

        # Post-process: Convert Python types to TypeScript
        convert_to_typescript(output_path)

        print(f"Successfully generated TypeScript types at {output_path}")
        return True

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return False


def convert_to_typescript(python_file: Path) -> None:
    """
    Convert Python dataclasses to TypeScript interfaces.

    This is a simple conversion that transforms the generated Python
    dataclasses into TypeScript interfaces.
    """
    content = python_file.read_text()

    # Type mappings
    type_map = {
        "str": "string",
        "int": "number",
        "float": "number",
        "bool": "boolean",
        "None": "null",
        "Any": "any",
        "dict": "Record<string, any>",
        "list": "Array",
        "Dict[str, Any]": "Record<string, any>",
        "List[str]": "string[]",
        "List[int]": "number[]",
        "Optional[str]": "string | null",
        "Optional[int]": "number | null",
        "Optional[float]": "number | null",
        "Optional[bool]": "boolean | null",
    }

    # Convert imports to TypeScript comment
    lines = content.split("\n")
    ts_lines = [
        "// Auto-generated TypeScript types from OpenAPI specification",
        "// Generated by scripts/generate_typescript_sdk.py",
        "// Do not edit manually - regenerate from OpenAPI spec",
        "",
    ]

    in_class = False
    class_name = ""

    for line in lines:
        # Skip Python imports
        if line.startswith("from ") or line.startswith("import "):
            continue

        # Convert class to interface
        if line.startswith("class "):
            in_class = True
            # Extract class name
            match_cls = line.split("class ")[1].split("(")[0].split(":")[0].strip()
            class_name = match_cls
            ts_lines.append(f"export interface {class_name} {{")
            continue

        # Convert fields
        if in_class and ":" in line and not line.strip().startswith("#"):
            stripped = line.strip()
            if stripped and not stripped.startswith("def "):
                # Parse field: name: type = default
                parts = stripped.split(":")
                if len(parts) >= 2:
                    field_name = parts[0].strip()
                    type_part = parts[1].split("=")[0].strip()

                    # Convert type
                    ts_type = type_map.get(type_part, type_part)

                    # Handle Optional
                    if "Optional[" in type_part or "| None" in type_part:
                        inner = type_part.replace("Optional[", "").replace("]", "")
                        inner = inner.replace(" | None", "")
                        ts_type = f"{type_map.get(inner, inner)} | null"
                        field_name += "?"

                    ts_lines.append(f"  {field_name}: {ts_type};")

        # End of class
        if in_class and line and not line.startswith(" ") and not line.startswith("class"):
            ts_lines.append("}")
            ts_lines.append("")
            in_class = False

    # Close last class if needed
    if in_class:
        ts_lines.append("}")

    # Write TypeScript file
    ts_content = "\n".join(ts_lines)
    python_file.with_suffix(".ts").write_text(ts_content)

    # Also keep the Python file but rename it
    # python_file.rename(python_file.with_suffix(".py.bak"))


def generate_api_client_types(openapi_path: Path, output_path: Path) -> bool:
    """
    Generate API client types directly from OpenAPI spec.

    This generates clean TypeScript interfaces for request/response types.
    """
    if not openapi_path.exists():
        print(f"Error: OpenAPI spec not found at {openapi_path}", file=sys.stderr)
        return False

    with open(openapi_path) as f:
        spec = json.load(f)

    schemas = spec.get("components", {}).get("schemas", {})

    lines = [
        "// Auto-generated TypeScript types from OpenAPI specification",
        "// Generated by scripts/generate_typescript_sdk.py",
        f"// OpenAPI version: {spec.get('info', {}).get('version', 'unknown')}",
        "// Do not edit manually - regenerate from OpenAPI spec",
        "",
        "/* eslint-disable @typescript-eslint/no-explicit-any */",
        "",
    ]

    def convert_schema_to_ts(schema: dict, indent: int = 0) -> str:
        """Convert OpenAPI schema to TypeScript type."""
        prefix = "  " * indent

        if "$ref" in schema:
            ref_name = schema["$ref"].split("/")[-1]
            return ref_name

        schema_type = schema.get("type")

        if schema_type == "string":
            if "enum" in schema:
                return " | ".join(f'"{v}"' for v in schema["enum"])
            return "string"
        elif schema_type == "integer" or schema_type == "number":
            return "number"
        elif schema_type == "boolean":
            return "boolean"
        elif schema_type == "array":
            items = schema.get("items", {})
            item_type = convert_schema_to_ts(items, indent)
            return f"{item_type}[]"
        elif schema_type == "object":
            props = schema.get("properties", {})
            required = set(schema.get("required", []))
            if not props:
                return "Record<string, any>"

            prop_lines = []
            for prop_name, prop_schema in props.items():
                optional = "?" if prop_name not in required else ""
                prop_type = convert_schema_to_ts(prop_schema, indent + 1)
                prop_lines.append(f"{prefix}  {prop_name}{optional}: {prop_type};")

            return "{\n" + "\n".join(prop_lines) + f"\n{prefix}}}"

        return "any"

    # Generate interfaces for each schema
    for name, schema in schemas.items():
        if schema.get("type") == "object" or "properties" in schema:
            lines.append(f"export interface {name} {{")
            props = schema.get("properties", {})
            required = set(schema.get("required", []))

            for prop_name, prop_schema in props.items():
                optional = "?" if prop_name not in required else ""
                prop_type = convert_schema_to_ts(prop_schema, 1)
                description = prop_schema.get("description", "")
                if description:
                    lines.append(f"  /** {description} */")
                lines.append(f"  {prop_name}{optional}: {prop_type};")

            lines.append("}")
            lines.append("")
        elif "enum" in schema:
            values = " | ".join(f'"{v}"' for v in schema["enum"])
            lines.append(f"export type {name} = {values};")
            lines.append("")

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(lines))

    print(f"Generated {len(schemas)} TypeScript types at {output_path}")
    return True


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Generate TypeScript SDK types from OpenAPI specification"
    )
    parser.add_argument(
        "--openapi",
        type=Path,
        default=DEFAULT_OPENAPI_PATH,
        help=f"Path to OpenAPI spec (default: {DEFAULT_OPENAPI_PATH})",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT_PATH,
        help=f"Output path for TypeScript file (default: {DEFAULT_OUTPUT_PATH})",
    )
    parser.add_argument(
        "--method",
        choices=["direct", "codegen"],
        default="direct",
        help="Generation method: direct (parse OpenAPI) or codegen (use datamodel-codegen)",
    )

    args = parser.parse_args()

    if args.method == "codegen":
        if not check_dependencies():
            return 1
        success = generate_typescript_types(args.openapi, args.output)
    else:
        success = generate_api_client_types(args.openapi, args.output)

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
