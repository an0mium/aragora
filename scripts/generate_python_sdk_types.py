#!/usr/bin/env python3
"""
Generate Python SDK Pydantic models from OpenAPI spec.

Uses datamodel-code-generator to create type-safe Pydantic models
from the OpenAPI 3.1 specification.

Usage:
  python scripts/generate_python_sdk_types.py
  python scripts/generate_python_sdk_types.py --check
  python scripts/generate_python_sdk_types.py --output sdk/python/aragora/generated_types.py

Requirements:
  pip install datamodel-code-generator
"""

from __future__ import annotations

import argparse
import subprocess
import sys
import tempfile
from pathlib import Path


DEFAULT_OPENAPI = Path("docs/api/openapi.json")
DEFAULT_OUTPUT = Path("sdk/python/aragora/generated_types.py")


def check_datamodel_codegen() -> bool:
    """Check if datamodel-code-generator is installed."""
    try:
        subprocess.run(
            ["datamodel-codegen", "--version"],
            capture_output=True,
            check=True,
        )
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def generate_types(openapi_path: Path, output_path: Path) -> int:
    """Generate Python Pydantic models from the OpenAPI spec.

    Always generates to a temp directory first to ensure consistent output
    regardless of destination path (datamodel-codegen picks up local ruff/black
    config which can vary between directories).
    """
    with tempfile.TemporaryDirectory() as tmpdir:
        temp_out = Path(tmpdir) / output_path.name
        cmd = [
            "datamodel-codegen",
            "--input",
            str(openapi_path),
            "--input-file-type",
            "openapi",
            "--output",
            str(temp_out),
            "--use-annotated",
            "--field-constraints",
            "--use-double-quotes",
            "--target-python-version",
            "3.11",
            "--use-standard-collections",
            "--use-union-operator",
            "--collapse-root-models",
            "--enum-field-as-literal",
            "one",
        ]

        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            print(f"Error generating types: {result.stderr}", file=sys.stderr)
            return result.returncode

        # Copy to destination (avoiding local config differences)
        output_path.write_text(temp_out.read_text())

    return 0


def format_output(output_path: Path) -> None:
    """Format the generated file with ruff if available."""
    try:
        subprocess.run(
            ["ruff", "format", str(output_path)],
            capture_output=True,
            check=False,
        )
    except FileNotFoundError:
        pass  # ruff not installed, skip formatting


def normalize_content(content: str) -> str:
    """Remove timestamps and normalize content for comparison.

    We normalize aggressively to handle ruff formatting differences
    which can vary based on line length calculations.
    """
    import re

    # Remove timestamp comments from datamodel-codegen
    content = re.sub(r"#\s+timestamp:.*\n", "", content)
    # Normalize filename comments (openapi.json vs openapi_generated.json)
    content = re.sub(
        r"#\s+filename:\s+openapi[_a-z]*\.json", "#   filename:  openapi.json", content
    )
    # Normalize whitespace at end of lines
    content = "\n".join(line.rstrip() for line in content.split("\n"))
    # Collapse multiple blank lines to single
    content = re.sub(r"\n\n\n+", "\n\n", content)
    # Remove trailing comma differences in Field() by normalizing
    content = re.sub(r",(\s*)\)", r"\1)", content)
    return content


def add_header(output_path: Path) -> None:
    """Add a header comment to the generated file."""
    content = output_path.read_text()
    # Remove the timestamp line from datamodel-codegen output
    content = normalize_content(content)
    header = '''"""
Auto-generated Pydantic models from OpenAPI specification.

DO NOT EDIT - This file is auto-generated by scripts/generate_python_sdk_types.py
To regenerate: python scripts/generate_python_sdk_types.py

Generated from: docs/api/openapi.json
"""

'''
    output_path.write_text(header + content)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate Python SDK types from OpenAPI spec")
    parser.add_argument(
        "--openapi",
        type=Path,
        default=DEFAULT_OPENAPI,
        help=f"Path to OpenAPI spec (default: {DEFAULT_OPENAPI})",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help=f"Output file path (default: {DEFAULT_OUTPUT})",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        help="Check if generated output matches existing file",
    )
    args = parser.parse_args()

    # Check dependencies
    if not check_datamodel_codegen():
        print(
            "datamodel-code-generator not installed. Install with:",
            file=sys.stderr,
        )
        print("  pip install datamodel-code-generator", file=sys.stderr)
        sys.exit(1)

    # Check input exists
    if not args.openapi.exists():
        print(f"OpenAPI spec not found: {args.openapi}", file=sys.stderr)
        sys.exit(1)

    if args.check:
        # Check mode: generate to temp file and compare
        if not args.output.exists():
            print(f"Expected output not found: {args.output}", file=sys.stderr)
            print("Run without --check to generate the file.", file=sys.stderr)
            sys.exit(1)

        with tempfile.TemporaryDirectory() as tmpdir:
            temp_out = Path(tmpdir) / args.output.name
            code = generate_types(args.openapi, temp_out)
            if code != 0:
                sys.exit(code)

            add_header(temp_out)
            # Run ruff format for consistent comparison
            format_output(temp_out)

            # Normalize both for comparison (timestamps, whitespace)
            generated = normalize_content(temp_out.read_text())
            existing = normalize_content(args.output.read_text())

            if generated != existing:
                print("Generated Python SDK types are out of date.", file=sys.stderr)
                print("Run: python scripts/generate_python_sdk_types.py", file=sys.stderr)
                sys.exit(1)

        print("Python SDK types are up to date.")
        return

    # Generate mode
    args.output.parent.mkdir(parents=True, exist_ok=True)
    code = generate_types(args.openapi, args.output)

    if code == 0:
        add_header(args.output)
        # Run ruff format to match pre-commit hook output
        format_output(args.output)
        print(f"Generated: {args.output}")

    sys.exit(code)


if __name__ == "__main__":
    main()
