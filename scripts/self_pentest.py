#!/usr/bin/env python3
"""
Self-Penetration Testing Script - Aragora Dogfooding.

Uses Aragora's own security analysis capabilities to scan itself for vulnerabilities.
This demonstrates the platform's security features while finding real issues.

Capabilities used:
1. SecurityScanner - Pattern-based vulnerability detection (secrets, injection, config)
2. SASTScanner - Semgrep-based static analysis with OWASP Top 10
3. CodeReviewOrchestrator - Multi-agent security-focused code review
4. GauntletOrchestrator - Adversarial security validation with red-teaming

Usage:
    python scripts/self_pentest.py [--quick] [--full] [--output report.md]

    --quick: Pattern scan only (fastest, no API calls)
    --full:  Full analysis including LLM-based review (requires API keys)
    --output: Write markdown report to file
"""

import argparse
import asyncio
import json
import sys
from datetime import datetime
from pathlib import Path
from typing import Any

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))


class SelfPentestRunner:
    """Orchestrates self-penetration testing using Aragora's security tools."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.results: dict[str, Any] = {
            "timestamp": datetime.now().isoformat(),
            "project": "aragora",
            "scans": {},
        }

    async def run_security_scanner(self) -> dict[str, Any]:
        """Run pattern-based security scanning."""
        print("\n" + "=" * 60)
        print("Phase 1: Pattern-Based Security Scan")
        print("=" * 60)

        try:
            from aragora.audit.security_scanner import SecurityScanner

            scanner = SecurityScanner()
            code_dir = self.project_root / "aragora"

            print(f"Scanning: {code_dir}")
            report = scanner.scan_directory(str(code_dir))

            summary = {
                "total_findings": len(report.findings),
                "critical": report.critical_count,
                "high": report.high_count,
                "medium": report.medium_count,
                "low": report.low_count,
                "risk_score": report.risk_score,
                "findings_by_category": {},
            }

            # Group by category
            for finding in report.findings:
                cat = finding.category
                if cat not in summary["findings_by_category"]:
                    summary["findings_by_category"][cat] = []
                summary["findings_by_category"][cat].append(
                    {
                        "severity": finding.severity,
                        "file": finding.file_path,
                        "line": finding.line_number,
                        "description": finding.description,
                        "cwe_id": finding.cwe_id,
                    }
                )

            print("\nResults:")
            print(f"  Critical: {summary['critical']}")
            print(f"  High:     {summary['high']}")
            print(f"  Medium:   {summary['medium']}")
            print(f"  Low:      {summary['low']}")
            print(f"  Risk Score: {summary['risk_score']:.2f}")

            return summary

        except ImportError as e:
            print(f"  SecurityScanner not available: {e}")
            return {"error": str(e)}
        except Exception as e:
            print(f"  Error: {e}")
            return {"error": str(e)}

    async def run_sast_scanner(self) -> dict[str, Any]:
        """Run SAST analysis with Semgrep."""
        print("\n" + "=" * 60)
        print("Phase 2: SAST Analysis (Semgrep)")
        print("=" * 60)

        try:
            from aragora.analysis.codebase.sast_scanner import SASTScanner

            scanner = SASTScanner()
            code_dir = self.project_root / "aragora"

            print(f"Scanning: {code_dir}")
            print("  (This may take a few minutes...)")

            result = await scanner.scan_directory(
                str(code_dir),
                rule_sets=["python.lang.security", "python.django.security"],
            )

            summary = {
                "total_findings": len(result.findings) if result.findings else 0,
                "by_severity": {},
                "by_cwe": {},
            }

            if result.findings:
                for finding in result.findings:
                    sev = finding.severity
                    summary["by_severity"][sev] = summary["by_severity"].get(sev, 0) + 1
                    if finding.cwe_id:
                        summary["by_cwe"][finding.cwe_id] = (
                            summary["by_cwe"].get(finding.cwe_id, 0) + 1
                        )

            print(f"\nResults: {summary['total_findings']} findings")
            for sev, count in summary["by_severity"].items():
                print(f"  {sev}: {count}")

            return summary

        except ImportError as e:
            print(f"  SASTScanner not available: {e}")
            return {"error": str(e), "note": "Install semgrep for SAST analysis"}
        except Exception as e:
            print(f"  Error: {e}")
            return {"error": str(e)}

    async def run_code_review(self, files: list[str] | None = None) -> dict[str, Any]:
        """Run multi-agent security code review."""
        print("\n" + "=" * 60)
        print("Phase 3: Multi-Agent Security Code Review")
        print("=" * 60)

        try:
            from aragora.agents.code_reviewer import CodeReviewOrchestrator

            # Focus on security-critical files
            if files is None:
                files = [
                    "aragora/auth/oidc.py",
                    "aragora/auth/api_key.py",
                    "aragora/server/middleware/auth.py",
                    "aragora/server/handlers/auth/login_handlers.py",
                    "aragora/storage/secrets.py",
                    "aragora/tenancy/isolation.py",
                ]

            reviewer = CodeReviewOrchestrator()
            all_findings = []

            for file_path in files:
                full_path = self.project_root / file_path
                if not full_path.exists():
                    print(f"  Skipping (not found): {file_path}")
                    continue

                print(f"  Reviewing: {file_path}")
                try:
                    code = full_path.read_text()
                    findings = await reviewer.review_code(
                        code=code,
                        file_path=file_path,
                        focus_areas=["security"],
                    )
                    all_findings.extend(findings)
                except Exception as e:
                    print(f"    Error: {e}")

            summary = {
                "files_reviewed": len(files),
                "total_findings": len(all_findings),
                "by_category": {},
                "critical_findings": [],
            }

            for finding in all_findings:
                cat = finding.category if hasattr(finding, "category") else "UNKNOWN"
                summary["by_category"][cat] = summary["by_category"].get(cat, 0) + 1
                if hasattr(finding, "severity") and finding.severity == "CRITICAL":
                    summary["critical_findings"].append(
                        {
                            "file": finding.file_path
                            if hasattr(finding, "file_path")
                            else "unknown",
                            "message": finding.message
                            if hasattr(finding, "message")
                            else str(finding),
                        }
                    )

            print(
                f"\nResults: {summary['total_findings']} findings across {summary['files_reviewed']} files"
            )

            return summary

        except ImportError as e:
            print(f"  CodeReviewOrchestrator not available: {e}")
            return {"error": str(e)}
        except Exception as e:
            print(f"  Error: {e}")
            return {"error": str(e)}

    async def run_gauntlet(self) -> dict[str, Any]:
        """Run Gauntlet adversarial security validation."""
        print("\n" + "=" * 60)
        print("Phase 4: Gauntlet Adversarial Security Validation")
        print("=" * 60)

        try:
            from aragora.gauntlet.orchestrator import GauntletOrchestrator
            from aragora.gauntlet.templates import GauntletTemplate

            orchestrator = GauntletOrchestrator()

            # Prepare security-focused input
            security_context = """
            Aragora Security Architecture Analysis

            Authentication:
            - JWT-based authentication with refresh tokens
            - API key management with scoping
            - OIDC/SAML SSO integration
            - MFA support (TOTP/HOTP)

            Authorization:
            - RBAC v2 with 50+ permissions
            - Role hierarchy (admin, moderator, user, viewer)
            - Tenant isolation with org_id boundaries

            Data Protection:
            - AES-256-GCM encryption at rest
            - TLS 1.3 in transit
            - Secrets stored in encrypted vault

            API Security:
            - Rate limiting per user/IP/key
            - Input validation on all endpoints
            - CORS configuration

            Analyze this architecture for potential vulnerabilities.
            """

            print("  Running security assessment template...")
            result = await orchestrator.run(
                input_text=security_context,
                template=GauntletTemplate.SECURITY_ASSESSMENT,
                context={"project": "aragora", "mode": "self-pentest"},
            )

            summary = {
                "verdict": result.verdict if hasattr(result, "verdict") else "unknown",
                "risk_score": result.risk_score if hasattr(result, "risk_score") else 0,
                "findings_count": len(result.findings) if hasattr(result, "findings") else 0,
                "phases_completed": len(result.phase_results)
                if hasattr(result, "phase_results")
                else 0,
            }

            print("\nResults:")
            print(f"  Verdict: {summary['verdict']}")
            print(f"  Risk Score: {summary['risk_score']:.2f}")
            print(f"  Findings: {summary['findings_count']}")

            return summary

        except ImportError as e:
            print(f"  GauntletOrchestrator not available: {e}")
            return {"error": str(e)}
        except Exception as e:
            print(f"  Error: {e}")
            return {"error": str(e)}

    def generate_report(self) -> str:
        """Generate markdown report from results."""
        lines = [
            "# Aragora Self-Penetration Test Report",
            "",
            f"**Generated:** {self.results['timestamp']}",
            f"**Target:** {self.results['project']}",
            "",
            "---",
            "",
        ]

        # Executive Summary
        lines.append("## Executive Summary\n")

        total_critical = 0
        total_high = 0

        if "security_scanner" in self.results["scans"]:
            scan = self.results["scans"]["security_scanner"]
            if "error" not in scan:
                total_critical += scan.get("critical", 0)
                total_high += scan.get("high", 0)

        lines.append(f"- **Critical Issues:** {total_critical}")
        lines.append(f"- **High Issues:** {total_high}")
        lines.append("")

        # Detailed Results
        for phase, data in self.results["scans"].items():
            lines.append(f"## {phase.replace('_', ' ').title()}\n")

            if "error" in data:
                lines.append(f"*Error: {data['error']}*\n")
                continue

            lines.append("```json")
            lines.append(json.dumps(data, indent=2, default=str))
            lines.append("```\n")

        # Recommendations
        lines.append("## Recommendations\n")
        lines.append("1. Address all CRITICAL findings immediately")
        lines.append("2. Review HIGH findings within 24 hours")
        lines.append("3. Schedule MEDIUM findings for next sprint")
        lines.append("4. Consider penetration testing by external vendor for SOC 2")
        lines.append("")

        return "\n".join(lines)

    async def run(self, quick: bool = False, full: bool = False) -> dict[str, Any]:
        """Run the self-pentest."""
        print("\n" + "=" * 60)
        print("  ARAGORA SELF-PENETRATION TEST")
        print("  Dogfooding Security Analysis Capabilities")
        print("=" * 60)

        # Phase 1: Always run pattern scan (fast, no API)
        self.results["scans"]["security_scanner"] = await self.run_security_scanner()

        if quick:
            print("\n[Quick mode - skipping LLM-based analysis]")
            return self.results

        # Phase 2: SAST (requires semgrep)
        self.results["scans"]["sast_scanner"] = await self.run_sast_scanner()

        if full:
            # Phase 3: Code Review (requires API keys)
            self.results["scans"]["code_review"] = await self.run_code_review()

            # Phase 4: Gauntlet (requires API keys)
            self.results["scans"]["gauntlet"] = await self.run_gauntlet()

        return self.results


async def main():
    parser = argparse.ArgumentParser(description="Aragora Self-Penetration Test")
    parser.add_argument("--quick", action="store_true", help="Quick scan only (no API calls)")
    parser.add_argument("--full", action="store_true", help="Full analysis with LLM review")
    parser.add_argument("--output", "-o", type=str, help="Output markdown report to file")
    args = parser.parse_args()

    runner = SelfPentestRunner(PROJECT_ROOT)
    results = await runner.run(quick=args.quick, full=args.full)

    # Generate report
    report = runner.generate_report()

    if args.output:
        Path(args.output).write_text(report)
        print(f"\nReport written to: {args.output}")
    else:
        print("\n" + report)

    # Exit with error code if critical issues found
    critical = results.get("scans", {}).get("security_scanner", {}).get("critical", 0)
    if critical > 0:
        print(f"\n⚠️  {critical} CRITICAL issues found!")
        sys.exit(1)

    print("\n✓ Self-pentest complete")


if __name__ == "__main__":
    asyncio.run(main())
