#!/usr/bin/env python3
"""
Gate CI on unresolved penetration-test findings.

Reads security/pentest/findings.json and:
  - Validates the JSON structure against the expected schema
  - Checks for any CRITICAL or HIGH findings with status "open"
  - Prints a summary table of all findings by severity and status
  - Exits 0 if no unresolved HIGH/CRITICAL findings
  - Exits 1 if unresolved HIGH/CRITICAL findings exist
  - Exits 2 on structural or file errors
"""

from __future__ import annotations

import argparse
import json
import sys
from collections import Counter
from pathlib import Path


BLOCKING_SEVERITIES = {"critical", "high"}
RESOLVED_STATUSES = {"resolved", "accepted_risk", "fixed", "mitigated", "closed", "false_positive"}
VALID_SEVERITIES = {"critical", "high", "medium", "low", "info"}
VALID_STATUSES = {"open", "in_progress", "resolved", "accepted_risk", "fixed", "mitigated", "closed", "false_positive"}

REQUIRED_TOP_LEVEL_KEYS = {"last_audit_date", "findings", "schema_version"}
REQUIRED_FINDING_KEYS = {"id", "severity", "title", "status"}


def _validate_schema(data: dict) -> list[str]:
    """Validate the top-level JSON structure. Returns a list of error messages."""
    errors: list[str] = []

    if not isinstance(data, dict):
        return ["Root element must be a JSON object"]

    for key in REQUIRED_TOP_LEVEL_KEYS:
        if key not in data:
            errors.append(f"Missing required top-level key: '{key}'")

    if "findings" in data and not isinstance(data["findings"], list):
        errors.append("'findings' must be a JSON array")

    if "schema_version" in data:
        version = data["schema_version"]
        if not isinstance(version, str):
            errors.append("'schema_version' must be a string")

    if "severity_levels" in data:
        if not isinstance(data["severity_levels"], list):
            errors.append("'severity_levels' must be a JSON array")

    if "scope" in data:
        if not isinstance(data["scope"], list):
            errors.append("'scope' must be a JSON array")

    return errors


def _validate_finding(finding: dict, index: int) -> list[str]:
    """Validate an individual finding entry. Returns a list of warnings."""
    warnings: list[str] = []

    if not isinstance(finding, dict):
        return [f"Finding at index {index} is not a JSON object"]

    for key in REQUIRED_FINDING_KEYS:
        if key not in finding:
            warnings.append(f"Finding at index {index}: missing required key '{key}'")

    severity = str(finding.get("severity", "")).strip().lower()
    if severity and severity not in VALID_SEVERITIES:
        warnings.append(
            f"Finding at index {index}: unknown severity '{finding.get('severity')}' "
            f"(expected one of: {', '.join(sorted(VALID_SEVERITIES))})"
        )

    status = str(finding.get("status", "")).strip().lower()
    if status and status not in VALID_STATUSES:
        warnings.append(
            f"Finding at index {index}: unknown status '{finding.get('status')}' "
            f"(expected one of: {', '.join(sorted(VALID_STATUSES))})"
        )

    return warnings


def _load_and_validate(path: Path) -> tuple[list[dict], list[str]]:
    """Load findings file and validate structure.

    Returns (findings_list, validation_warnings).
    Raises on fatal errors.
    """
    data = json.loads(path.read_text(encoding="utf-8"))

    schema_errors = _validate_schema(data)
    if schema_errors:
        raise ValueError(
            "Schema validation failed:\n" + "\n".join(f"  - {e}" for e in schema_errors)
        )

    findings = data.get("findings", [])
    if not isinstance(findings, list):
        raise ValueError("'findings' must be a list")

    warnings: list[str] = []
    valid_findings: list[dict] = []
    for i, finding in enumerate(findings):
        finding_warnings = _validate_finding(finding, i)
        warnings.extend(finding_warnings)
        if isinstance(finding, dict):
            valid_findings.append(finding)

    return valid_findings, warnings


def _print_summary_table(findings: list[dict]) -> None:
    """Print a summary table of findings grouped by severity and status."""
    if not findings:
        print("\n  No findings recorded.")
        return

    # Count by severity
    severity_counts: Counter[str] = Counter()
    status_counts: Counter[str] = Counter()
    severity_status: Counter[tuple[str, str]] = Counter()

    for f in findings:
        sev = str(f.get("severity", "unknown")).strip().upper()
        stat = str(f.get("status", "unknown")).strip().lower()
        severity_counts[sev] += 1
        status_counts[stat] += 1
        severity_status[(sev, stat)] += 1

    # Severity summary
    severity_order = ["CRITICAL", "HIGH", "MEDIUM", "LOW", "INFO"]
    present_severities = [s for s in severity_order if s in severity_counts]
    other_severities = sorted(set(severity_counts.keys()) - set(severity_order))
    all_severities = present_severities + other_severities

    # Status summary
    status_order = ["open", "in_progress", "resolved", "accepted_risk", "fixed", "closed"]
    present_statuses = [s for s in status_order if s in status_counts]
    other_statuses = sorted(set(status_counts.keys()) - set(status_order))
    all_statuses = present_statuses + other_statuses

    # Print severity x status matrix
    print("\n  Findings Summary")
    print("  " + "=" * 70)

    # Header row
    col_width = 14
    header = f"  {'Severity':<12}"
    for status in all_statuses:
        header += f"{status:>{col_width}}"
    header += f"{'TOTAL':>{col_width}}"
    print(header)
    print("  " + "-" * 70)

    # Data rows
    for sev in all_severities:
        row = f"  {sev:<12}"
        for status in all_statuses:
            count = severity_status.get((sev, status), 0)
            cell = str(count) if count > 0 else "."
            row += f"{cell:>{col_width}}"
        row += f"{severity_counts[sev]:>{col_width}}"
        print(row)

    # Totals row
    print("  " + "-" * 70)
    totals_row = f"  {'TOTAL':<12}"
    for status in all_statuses:
        totals_row += f"{status_counts[status]:>{col_width}}"
    totals_row += f"{len(findings):>{col_width}}"
    print(totals_row)
    print()


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Security: Pentest Findings Gate - check for unresolved HIGH/CRITICAL findings"
    )
    parser.add_argument(
        "--file",
        default="security/pentest/findings.json",
        help="Path to pentest findings JSON file (default: security/pentest/findings.json)",
    )
    args = parser.parse_args()

    path = Path(args.file)

    # --- File existence check ---
    if not path.exists():
        print(f"ERROR: Pentest findings file not found: {path}", file=sys.stderr)
        print(
            "  Create it with the expected schema. See security/pentest/findings.json.",
            file=sys.stderr,
        )
        return 2

    if not path.is_file():
        print(f"ERROR: Path is not a file: {path}", file=sys.stderr)
        return 2

    # --- Load and validate ---
    try:
        findings, warnings = _load_and_validate(path)
    except json.JSONDecodeError as exc:
        print(f"ERROR: Invalid JSON in {path}: {exc}", file=sys.stderr)
        return 2
    except (OSError, ValueError) as exc:
        print(f"ERROR: Failed to read pentest findings: {exc}", file=sys.stderr)
        return 2

    # Print validation warnings
    if warnings:
        print("Schema validation warnings:")
        for w in warnings:
            print(f"  WARNING: {w}")
        print()

    # --- Print summary table ---
    print(f"Pentest Findings Report ({path})")
    print(f"  Total findings: {len(findings)}")
    _print_summary_table(findings)

    # --- Check for blocking findings ---
    blocking: list[dict] = []
    for finding in findings:
        severity = str(finding.get("severity", "")).strip().lower()
        status = str(finding.get("status", "")).strip().lower()
        if severity in BLOCKING_SEVERITIES and status not in RESOLVED_STATUSES:
            blocking.append(finding)

    if blocking:
        print(f"FAILED: {len(blocking)} unresolved HIGH/CRITICAL finding(s) detected:\n")
        for finding in blocking:
            fid = finding.get("id", "UNKNOWN")
            severity = finding.get("severity", "unknown")
            status = finding.get("status", "unknown")
            title = finding.get("title", "(no title)")
            component = finding.get("affected_component", "")
            print(f"  [{severity.upper()}] {fid}: {title}")
            print(f"    Status: {status}")
            if component:
                print(f"    Component: {component}")
            cve = finding.get("cve")
            if cve:
                print(f"    CVE: {cve}")
            print()
        print("Resolve or accept-risk all HIGH/CRITICAL findings to pass this gate.")
        return 1

    # --- All clear ---
    resolved_count = sum(
        1 for f in findings
        if str(f.get("status", "")).strip().lower() in RESOLVED_STATUSES
    )
    print(
        f"PASSED: No unresolved HIGH/CRITICAL findings "
        f"(total={len(findings)}, resolved={resolved_count}, blocking_open=0)"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
