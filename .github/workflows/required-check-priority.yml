name: Required Check Priority

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]

concurrency:
  group: required-check-priority-${{ github.event.pull_request.number }}
  cancel-in-progress: false

permissions:
  actions: write
  checks: read
  contents: read

jobs:
  prioritize-required-checks:
    name: Prioritize Required Checks
    runs-on: ubuntu-latest
    if: github.event.pull_request.head.repo.full_name == github.repository
    timeout-minutes: 10

    steps:
      - name: Cancel non-required workflow runs for this PR head
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pr = context.payload.pull_request;
            const headSha = pr.head.sha;
            const headBranch = pr.head.ref;
            const baseBranch = pr.base.ref;
            const selfRunId = Number(process.env.GITHUB_RUN_ID);

            const sweeps = 4;
            const sweepDelayMs = 10000;

            // Required checks are currently produced by these workflows.
            // Keep this list in sync with branch protection required contexts.
            const alwaysKeepWorkflowPaths = new Set([
              '.github/workflows/lint.yml',
              '.github/workflows/sdk-parity.yml',
              '.github/workflows/sdk-test.yml',
              '.github/workflows/openapi.yml',
              '.github/workflows/required-check-priority.yml',
            ]);
            const alwaysKeepWorkflowNames = new Set([
              'Required Check Priority',
              'Lint',
              'SDK Parity Check',
              'SDK Tests',
              'OpenAPI Spec',
            ]);

            const requiredContexts = new Set();
            try {
              const { data: protection } = await github.rest.repos.getBranchProtection({
                owner,
                repo,
                branch: baseBranch,
              });
              for (const name of protection.required_status_checks?.contexts ?? []) {
                requiredContexts.add(name);
              }
              core.info(
                `Loaded required contexts from branch protection (${requiredContexts.size}): ` +
                  `${Array.from(requiredContexts).join(', ')}`
              );
            } catch (error) {
              core.warning(
                `Could not read branch protection for '${baseBranch}' ` +
                  `(continuing with static required-workflow keep-list): ${error.message}`
              );
            }
            const requiredContextsNormalized = new Set(
              Array.from(requiredContexts).map((value) => String(value || '').trim())
            );

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const canceledRuns = [];
            const seenRunIds = new Set();
            const requiredContextRunCache = new Map();
            let emptySweepCount = 0;

            async function runHasRequiredContext(run) {
              if (requiredContextsNormalized.size === 0) {
                return false;
              }
              if (requiredContextRunCache.has(run.id)) {
                return requiredContextRunCache.get(run.id);
              }

              const contextNames = new Set();
              const workflowName = String(run.name || '').trim();
              const registerName = (name) => {
                const normalized = String(name || '').trim();
                if (normalized) contextNames.add(normalized);
              };

              if (run.check_suite_id) {
                try {
                  const checkRuns = await github.paginate(github.rest.checks.listForSuite, {
                    owner,
                    repo,
                    check_suite_id: run.check_suite_id,
                    per_page: 100,
                  });
                  for (const checkRun of checkRuns) {
                    registerName(checkRun.name);
                  }
                } catch (error) {
                  core.warning(
                    `Could not inspect check runs for run ${run.id} (suite ${run.check_suite_id}): ${error.message}`
                  );
                }
              }

              // Fallback for runs where check suite data is not yet available.
              if (contextNames.size === 0) {
                try {
                  const jobs = await github.paginate(github.rest.actions.listJobsForWorkflowRun, {
                    owner,
                    repo,
                    run_id: run.id,
                    per_page: 100,
                  });
                  for (const job of jobs) {
                    const jobName = String(job.name || '').trim();
                    registerName(jobName);
                    if (workflowName && jobName) {
                      registerName(`${workflowName} / ${jobName}`);
                    }
                  }
                } catch (error) {
                  core.warning(`Could not inspect jobs for run ${run.id}: ${error.message}`);
                }
              }

              const hasRequired = Array.from(contextNames).some((name) =>
                requiredContextsNormalized.has(name)
              );
              requiredContextRunCache.set(run.id, hasRequired);
              return hasRequired;
            }

            for (let pass = 1; pass <= sweeps; pass++) {
              const { data: runPage } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                branch: headBranch,
                event: 'pull_request',
                per_page: 100,
              });
              const runs = runPage.workflow_runs || [];

              let passCanceled = 0;
              let passConsidered = 0;
              for (const run of runs) {
                if (run.head_sha !== headSha) continue;
                if (run.id === selfRunId) continue;
                if (run.status !== 'queued' && run.status !== 'in_progress') continue;
                passConsidered += 1;

                const workflowPath = (run.path || '').split('@')[0];
                const workflowName = String(run.name || '').trim();
                if (
                  alwaysKeepWorkflowPaths.has(workflowPath) ||
                  alwaysKeepWorkflowNames.has(workflowName)
                ) {
                  continue;
                }

                // Defensive check: if a non-allowlisted workflow run currently owns
                // a required status context, keep it.
                const hasRequiredContext = await runHasRequiredContext(run);
                if (hasRequiredContext) continue;

                try {
                  await github.rest.actions.cancelWorkflowRun({
                    owner,
                    repo,
                    run_id: run.id,
                  });
                  passCanceled += 1;
                  if (!seenRunIds.has(run.id)) {
                    seenRunIds.add(run.id);
                    canceledRuns.push({
                      id: run.id,
                      workflow: run.name,
                      status: run.status,
                    });
                  }
                  core.info(`Canceled run ${run.id} (${run.name})`);
                } catch (error) {
                  core.warning(`Failed to cancel run ${run.id} (${run.name}): ${error.message}`);
                }
              }

              core.info(
                `Sweep ${pass}/${sweeps}: considered ${passConsidered} run(s), canceled ${passCanceled} run(s)`
              );
              if (passCanceled === 0) {
                emptySweepCount += 1;
              } else {
                emptySweepCount = 0;
              }
              if (emptySweepCount >= 2) {
                core.info('No cancellable runs for two consecutive sweeps; exiting early');
                break;
              }
              if (pass < sweeps) {
                await sleep(sweepDelayMs);
              }
            }

            await core.summary
              .addHeading('Required Check Priority')
              .addRaw(`PR #${pr.number} (${headBranch} @ ${headSha})`, true)
              .addRaw(`Canceled runs: ${canceledRuns.length}`, true)
              .addTable([
                [
                  { data: 'Run ID', header: true },
                  { data: 'Workflow', header: true },
                  { data: 'Status', header: true },
                ],
                ...canceledRuns.map((run) => [String(run.id), run.workflow, run.status]),
              ])
              .write();
